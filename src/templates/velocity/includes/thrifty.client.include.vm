#parse( "header.include.vm" )
#parse( "schema.include.vm" )
#if($isAsync)
#set ($asyncSuffix = 'Async')
#set ($asyncComment = '(asynchronous implementation)')
#else
#set ($asyncSuffix = $null)
#set ($asyncComment = $null)
#end
#if(!$codewriter.existsDependencyPackage() || !$codewriter.existsDependencySrc())
$codewriter.setSaveCurrentFile(false);
#stop
#end
#set ($thriftPackage = ${codewriter.getDependencyPackage()})
#set ($swiftParser = $codewriter.loadExtensionClass("gu.rpc.thrift.SwiftServiceParser").newInstance())
#set ($typeUtils = $codewriter.loadExtensionClass("gu.rpc.thrift.ThriftyTypeUtils").newInstance())
#set ($javadocReader = $codewriter.loadExtensionClass("gu.doc.JavadocReader").newInstance())
#set ($serviceSrcDir = $codewriter.getProperty("swift.service.source"))
#set ($typeUtils.packagePrefixOfDao = $codewriter.getProperty('dao.package.prefix'))
#set ($typeUtils.packagePrefixOfThrift = $thriftPackage)
## $bean$用于替换beanClass
#set ($typeUtils.convertVar = 'converter$bean$')
#set ($typeUtils.toBytesMethodPrefix = 'GenericUtils.toBytes')
#set ($typeUtils.toBufferMethodPrefix = 'GenericUtils.toBuffer')
#set ($typeUtils.toLongMethodPrefix  = 'GenericUtils.toLong')
#set ($typeUtils.toDateMethodPrefix  = 'GenericUtils.toDate')
#set ($typeUtils.checkNotNullElementPrefix = 'CollectionUtils.checkNotNullElement')
#set ($classpath = $codewriter.getPropertyExploded("swift.service.classpath"))
#set ($serviceClassName = $codewriter.getProperty("swift.service.classname"))
#set ($metadata = $swiftParser.parse($serviceClassName,$classpath))
#set ($serviceSourceFile = $codewriter.getSourceFile($serviceSrcDir,$swiftParser.serviceClass))
#set ($serviceComment    = $javadocReader.read($serviceSourceFile))
#set ( $thriftSrc = $codewriter.getDependencySrc())
## 服务端运行时异常类名
#set ( $runtimeErrorName = $codewriter.getProperty('swift.service.exception.runtime','ServiceRuntimeException'))
#set ($nothing = $swiftParser.setRuntimeErrorName($runtimeErrorName))
#set ( $serviceName = ${metadata.name} )
## 删除原注释中的 @throws 标记
#if($isAsync)
#set ($nothing = $serviceComment.addExcludeTag("@throws"))
#else
#set ($nothing = $serviceComment.removeExcludeTag("@throws"))
#end
## 修改注释
#set ($nothing = $serviceComment.additionalText("remote implementation of the service $serviceName$!asyncComment<br>
all method comments be copied from {@code ${swiftParser.serviceClass.name}.java}<br>
<b>NOTE 1:</b>methods with 'Generic' suffix support generic type argument for {@code byte[]}.See also {@link GenericUtils${esc.hash}toBytes(Object)}<br>
<b>NOTE 2:</b>for each method,{@link List} type input argument must not have {@code null} element.<br>
","APPEND","CLASS"))
#set ( $javaClassName = "${serviceName}Client$!asyncSuffix" )
$codewriter.setCurrentJavaFilename("${gpkg}", "${javaClassName}.java")
package ${gpkg};

#if($isAsync)
import com.google.common.base.Function;
import com.google.common.util.concurrent.ListenableFuture;
import com.google.common.util.concurrent.SettableFuture;
#else
import com.google.common.base.Function;
import com.google.common.base.Throwables;
#end
import java.util.concurrent.atomic.AtomicReference;
import com.microsoft.thrifty.ThriftException;
import com.microsoft.thrifty.service.ServiceMethodCallback;
import com.microsoft.thrifty.service.AsyncClientBase;
import static com.google.common.base.Preconditions.*;
import java.nio.ByteBuffer;
import java.io.IOException;
import java.util.*;

#macro( eachDepencyTable $do $separator)
#set ( $m_count = 0 )
#foreach($table in $tables)
#set ( $leftClass  = "${table.asBeanClassNSP()}" )
#if($codewriter.existsInDependencyPackage($leftClass))
#set ( $m_count = $m_count + 1 )
#set ( $rightClass = "${thriftPackage}.${leftClass}" )#if( $m_count > 1 )$!separator#end#evaluate($do)#end
#end
#end
#define($interfaceClass)${thriftPackage}.${serviceName}#end
$!{serviceComment.getClassComment()}
public class $javaClassName implements Constant{
## 从properties 文件中读取converter的初始化代码
#set ( $converterInit = $codewriter.getProperty('swift.service.converter.init'))
    #eachDepencyTable("
    /** bean converter between {@link $leftClass} and corresponding thrift bean */
    private IBeanConverter<$leftClass,$rightClass> ${table.asConverterVar()} $!converterInit;" $null)
## 如果properties 文件中没有指定初始化代码,就生成getter/setter方法
#if(!$converterInit)
#eachDepencyTable('
    /** 
     * @return converter of {@link $leftClass}
     */
    public IBeanConverter<$leftClass,$rightClass> get${leftClass}Converter(){
        return ${table.asConverterVar()};
    }
    /** 
     * setup converter of {@link $leftClass}
     * @param ${table.asConverterVar()} must not be null. 
     */
    public void set${leftClass}Converter(IBeanConverter<$leftClass,$rightClass> ${table.asConverterVar()}){
        this.${table.asConverterVar()} = checkNotNull(${table.asConverterVar()});
    }' $null)
#end##(!$converterInit)


    private final ClientFactory factory;
    /**
     * constructor 
     * @param service a instance of ${interfaceClass} created by Swift, must not be null
     */
    $javaClassName(ClientFactory factory){
        this.factory = checkNotNull(factory,"factory is null");
    }
    /**
     * 当前调用的回调函数，由当前接口方法设置
     */
    private final AtomicReference<ServiceMethodCallback<?>> currentCallback = new AtomicReference<ServiceMethodCallback<?>>();
    private final AsyncClientBase.Listener closeListener = new AsyncClientBase.Listener(){
        @Override
        public void onTransportClosed() {
        }

        @Override
        public void onError(Throwable error) {
            currentCallback.get().onError(error);
        }        
    };
#if($isAsync)    
    private class MethodCallback<L,R> implements ServiceMethodCallback<R>{
        final net.gdface.facelog.client.thrift.IFaceLogClient service = factory.applyInstance(closeListener);
        final SettableFuture<L> feature = SettableFuture.create();
        final Function<R,L> transformer;

        MethodCallback(Function<R, L> transformer) {
            this.transformer = transformer;
            currentCallback.set(this);
        }

        @Override
        public void onSuccess(R result) {
            feature.set(transformer.apply(result));            
            try {
                service.close();
            } catch (IOException e) {
            }
        }

        @Override 
        public void onError(Throwable error) {            
            if(error instanceof ThriftException ){
                if(((ThriftException)error).kind == ThriftException.Kind.MISSING_RESULT  ){
                    this.onSuccess(null);
                }
            }
            feature.setException(error);
            try {
                service.close();
            } catch (IOException e) {
            }
        }
    }
#else
    private interface ServiceCall<T> {
        public void call(ServiceMethodCallback<T> callback);
    }
    /**
     * 异常调用转同步调用实现
     * @param transformer
     * @param serviceCall
     * @return
     */
    protected <R,L>R syncCall(final Function<L, R> transformer,final ServiceCall<L> serviceCall){
        final AtomicReference<R> res = new AtomicReference<R>(null);
        final AtomicReference<Throwable> err = new AtomicReference<Throwable>(null);
        final Object lock = new Object();
        final ServiceMethodCallback<L> callback = new ServiceMethodCallback<L>() {

            @Override
            public void onSuccess(L result) {
                res.set(transformer.apply(result));
                synchronized(lock){
                    lock.notifyAll();
                }
            }

            @Override
            public void onError(Throwable error) {
                err.set(error);
                synchronized(lock){
                    lock.notifyAll();
                }
            }
        };
        currentCallback.set(callback);
        synchronized(lock){
            try {
                serviceCall.call(callback);
                lock.wait();
            } catch (InterruptedException e) {
                err.set(e);
            }
        }
        if(null != err.get()){
            try{
                throw err.get();
            }catch(net.gdface.facelog.client.thrift.ServiceRuntimeException e){
                throw new ServiceRuntimeException(e);
            }
            catch(ThriftException e){
                if(e.kind == ThriftException.Kind.MISSING_RESULT  ){
                    return null;
                }
            }
            catch (Throwable e) {
                Throwables.throwIfUnchecked(e);
                throw new RuntimeException(e);                
            }
        }
        return res.get();
    }    
#end
## 
## 生成方法参数列表
#macro(eachparam $method $params)
#set ($thriftSignture = $swiftParser.signtureOfMethod($method))
$typeUtils.formateParam($method.method,$thriftSignture,$params)#end##macro(signture)
#########################
#macro(defineMethod $isGeneric)
#set ($thriftReturnType = $method.returnType.javaType)
#### 计算方法的返回值类型
#set ($returnType = $typeUtils.returnTypeOfMethod($method.method,$thriftReturnType))
#if(!$typeUtils.isVoid($returnType) || $isAsync)
#set ( $thriftReturn = "return ")
#else
#set ( $thriftReturn = $null)
#end
############## 定义返回类型输出字符串#######
#define($returnTypeStr)
#set ($tmp = $typeUtils.asReturnType($returnType,$isAsync))
#if($isAsync)ListenableFuture<$tmp>#else$tmp#end#end####define($returnTypeStr)
###################
#if($isGeneric)
    // $velocityCount GENERIC
    /** 
     * Generic version of {@link ${esc.hash}${method.method.name}(#eachparam($method {'withType':true,'rawTypeOnly':true}))}<br>
     * {@code Object} type instead of all argument with {@code byte[]} type,which can read binary data,
     * such as {@code InputStream,URL,URI,File,ByteBuffer},supported type depend on {@link GenericUtils#toBytes(Object)} <br>
     * @see GenericUtils#toBytes(Object)
     */
#else
    // $velocityCount SERIVCE PORT : $method.name
$!{serviceComment.getMethodComment($method.method)}
#end
    public $returnTypeStr ${method.method.name}#if($isGeneric)Generic#end(#eachparam($method {'isGeneric':$isGeneric,'withFinal':true,'withType':true,'withName':true, 'indent':'
            '}))$swiftParser.defineThrows($method,$isAsync,$thriftPackage){
#define( $callThrift )service.${method.name}(#eachparam($method {'isGeneric':$isGeneric,'toRight':true,'withName':true, 'indent':'
                    '})#if(${method.parameters.empty})#else,#{end}nativeCallback)#end
#if($isAsync)
#if($typeUtils.needFromRight($returnType))
#set ( $fromType = $typeUtils.asSwiftType($thriftReturnType,$thriftPackage))
#set ( $toType = $typeUtils.asJavaType($returnType))
#else
#set ( $fromType = $typeUtils.asReturnType($returnType,true))
#set ( $toType = $fromType)
#end
        MethodCallback<$toType,$fromType> nativeCallback = 
            new MethodCallback<$toType,$fromType>(
                new Function<$fromType,$toType>() {
                        @Override
                        public $toType apply($fromType input) {
                            return $typeUtils.fromRight($returnType,"input");
                }});
        nativeCallback.$callThrift;
        return nativeCallback.feature;
#else
## 抛出本地的基于RuntimeException的 ServiceRuntimeException
#if($typeUtils.needFromRight($returnType))
#set ( $fromType = $typeUtils.asSwiftType($thriftReturnType,$thriftPackage))
#set ( $toType = $typeUtils.asJavaType($returnType))
#else
#set ( $fromType = $typeUtils.asReturnType($returnType,true))
#set ( $toType = $fromType)
#end
        final ${interfaceClass}Client service = factory.applyInstance(closeListener);
        try{
            $!{thriftReturn}syncCall(new Function<$fromType,$toType>() {
                    @Override
                    public $toType apply($fromType input) {
                        return $typeUtils.fromRight($returnType,"input");
                    }},
                    new ServiceCall<$fromType>(){
                    @Override
                    public void call(ServiceMethodCallback<$fromType> nativeCallback){
                        $callThrift;
                    }
                });
        }finally{
            try {
                service.close();
            } catch (IOException e) {
            }
        }
#end###if($isAsync && $typeUtils.needFromRight($returnType))
    }
#end###macro(defineMethod)
## 将所有方法按方法名字排序
##set($thriftMethods = $sorter.sort($metadata.methods.values(),"name"))
## 将所有方法按源码中定义的顺序排序
#set($thriftMethods = $swiftParser.sortByDefined($metadata,$serviceComment.indexOf($swiftParser.methodsOf($metadata))))
## 遍历所有方法输出
#foreach($method in $thriftMethods)
#defineMethod(false)
## 生成泛型方法
#if($typeUtils.existsBinaryParam($method.method))
#defineMethod(true)
#end
#end
## 导入扩展模板
#if($swfitExtensiveTemplate)
#parse($swfitExtensiveTemplate)
#end

}