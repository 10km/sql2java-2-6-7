##included template: bean.include.vm
#parse( "header.include.vm" )
#parse( "table.include.vm" )
#parse( "macros.include.vm" )
#set ( $beanClass = $table.asBeanClass($isGeneral) )
#set ( $beanClassFullName = "$table.getPackage(true).${beanClass}" )
$codewriter.setCurrentJavaFilename($table.getPackage(true), "${beanClass}.java")
package $table.getPackage(true);
import java.io.Serializable;
import java.util.List;
import java.util.Objects;

#if(!$isGeneral)
import ${schemaPkg}.Constant;
import ${schemaPkg}.BaseBean;
#foreach ($foreignTable in $foreignTables)
#if(${foreignTable.getPackage(true)} != $table.getPackage(true))
import ${foreignTable.getPackage(true)}.${foreignTable.asBeanClass()};
#end
#end
import ${schemaPkg}.CompareToBuilder;
import ${schemaPkg}.EqualsBuilder;
import ${schemaPkg}.HashCodeBuilder;
#end
#swiftImport()
/**
 * $beanClass is a mapping of $table.getName() Table.
#if ( $table.getRemarks().length() > 0 )
 * <br>Meta Data Information (in progress):
 * <ul>
 *    <li>comments: $table.getRemarks() </li>
 * </ul>
#end
 * @author guyadong
*/
#swiftThriftStruct()
#set( $fieldIndex = 1 )
public $!{final} class ${beanClass}
    implements Serializable,BaseBean<$beanClass>,Comparable<$beanClass>,Constant,Cloneable
#if ($implementsClasses)
    #foreach( $implements in $implementsClasses )$implements #end
#end
{
    private static final long serialVersionUID = ${table.getSerialVersionUID($beanClassFullName)}L;
    /** NULL {@link $beanClass} bean , IMMUTABLE instance */
    public static final $beanClass NULL = new ${beanClass}().asNULL().asImmutable();
#foreach ( $column in $columns )
#if ( $column.getRemarks().length() > 0 )
    /** comments:$column.getRemarks() */
#end
    private $column.getJavaType() $column.getVarName();

#end
    /** flag whether {@code this} can be modified */
    private Boolean immutable;
    /** columns modified flag */
    private $table.stateVarType() modified;
    /** columns initialized flag */
    private $table.stateVarType() initialized;
    private boolean isNew;        
#if( $swiftBeanSupport && $table.countColumns() > 64  )
    private static final java.util.List<Long> toList(long[] array) {
        java.util.ArrayList<Long> result = new java.util.ArrayList<Long>(array.length);
        for (int i = 0; i < array.length; i++) {
            result.add(new Long(array[i]));
        }
        return result;
    }
    private static final void toPrimitive(java.util.List<Long> list,long[]dst) {
        if ( null == list  || list.size() != dst.length) {
            return;
        }
        Long element;
        for (int i = 0; i < dst.length; i++) {
            if(null != (element = list.get(i)))
                dst[i] = element.longValue();
        }
    }
#end
################## IMMUTABLE STATUS ###########
    /** 
     * set immutable status
     * @return {@code this} 
     */
    private $beanClass immutable(Boolean immutable) {
        this.immutable = immutable;
        return this;
    }
    /** 
     * set {@code this} as immutable object
     * @return {@code this} 
     */
    public $beanClass asImmutable() {
        return immutable(Boolean.TRUE);
    }
    /**
     * @return {@code true} if {@code this} is a mutable object  
     */
    public boolean mutable(){
        return !Boolean.TRUE.equals(this.immutable);
    }
    /**
     * @return {@code this}
     * @throws IllegalStateException if {@code this} is a immutable object 
     */
    private $beanClass checkMutable(){
        if(!mutable()){
            throw new IllegalStateException("this is a immutable object");
        }
        return this;
    }
    /**
     * @return return a new mutable copy of this object.
     */
    public $beanClass cloneMutable(){
        return clone().immutable(null);
    }
#swiftThriftField( $fieldIndex 'Requiredness.REQUIRED' '_new')
    @Override
    public boolean isNew()
    {
        return this.isNew;
    }


    @Override
    public void isNew(boolean isNew)
    {
        this.isNew = isNew;
    }
    /**
     * Specifies to the object if it has been set as new.
     *
     * @param isNew the boolean value to be assigned to the isNew field
     */
#swiftThriftField( $null $null $null)
    public void setNew(boolean isNew)
    {
        this.isNew = isNew;
    }
    /**
     * @return the modified status of columns
     */
#set( $fieldIndex = $fieldIndex + 1 )
#swiftThriftField( $fieldIndex 'Requiredness.REQUIRED' $null)
#if( $swiftBeanSupport && $table.countColumns() > 64  )
    public java.util.List<Long> getModified(){
        return toList(modified);
    }
#else
    public $table.stateVarType() getModified(){
        return modified;
    }
#end

    /**
     * @param modified the modified status bit to be assigned to {@link #modified}
     */
#swiftThriftField( $null $null $null)
#if( $swiftBeanSupport && $table.countColumns() > 64  )
    public void setModified(List<Long> modified){
        toPrimitive(modified,this.modified);
    }
#else
    public void setModified($table.stateVarType() modified){
        $table.stateVarAssignStatement("modified","this.modified");
    }
#end
    /**
     * @return the initialized status of columns
     */
#set( $fieldIndex = $fieldIndex + 1 )
#swiftThriftField( $fieldIndex 'Requiredness.REQUIRED' $null)
    public $table.stateVarType() getInitialized(){
        return initialized;
    }

    /**
     * @param initialized the initialized status bit to be assigned to {@link #initialized}
     */
#swiftThriftField( $null $null $null)
#if( $swiftBeanSupport && $table.countColumns() > 64  )
    public void setInitialized($table.stateVarType() initialized){
        toPrimitive(initialized,this.initialized);
    }
#else
    public void setInitialized($table.stateVarType() initialized){
        $table.stateVarAssignStatement("initialized","this.initialized");
    }
#end
    protected static final <T extends Comparable<T>>boolean equals(T a, T b) {
        return a == b || (a != null && 0==a.compareTo(b));
    }
    public ${beanClass}(){
        super();
        reset();
    }
#if ( $table.hasPrimaryKey() )
    /**
     * construct a new instance filled with primary keys
     * #join($primaryKeys '@param $e.getVarName() PK# $velocityCount ' '
     ')

     */
    public ${beanClass}(#join($primaryKeys '$e.getJavaType() $e.getVarName()' ',')){
        this();
        #join($primaryKeys '$e.getSetMethod()($e.getVarName());' '
        ')

    }
#end
#foreach ( $column in $columns )
#set( $fieldIndex = $fieldIndex + 1 )
    /**
     * Getter method for {@link #$column.getVarName()}.<br>
#if ( $column.isPrimaryKey() )
     * PRIMARY KEY.<br>
#end
     * Meta Data Information (in progress):
     * <ul>
     * <li>full name: $column.getFullName()</li>
#foreach ( $fKey in $column.getForeignKeys() )
     * <li> foreign key: ${fKey.getTableName()}.${fKey.getName()}</li>
#end
#foreach ( $iKey in $column.getImportedKeys() )
     * <li> imported key: ${iKey.getTableName()}.${iKey.getName()}</li>
#end
#if ( !$column.getRemarks().empty )
     * <li>comments: $column.getRemarks()</li>
#end
#if ( $column.getOriginalDefaultValue() )
     * <li>default value: '$column.getOriginalDefaultValue()'</li>
#end
#if ($column.isAutoincrement())
     * <li>AUTO_INCREMENT</li>
#end
#if ($column.isNotNull())
     * <li>NOT NULL</li>
#end
     * <li>column size: $column.getSize()</li>
     * <li>JDBC type returned by the driver: $column.getJavaTypeAsTypeName()</li>
     * </ul>
     *
     * @return the value of $column.getVarName()
     */
#if(!$column.isDate() && !$column.isFloat())#swiftThriftField( $fieldIndex $null)#end
    public $column.getJavaType() ${column.getGetMethod()}(){
        return $column.getVarName();
    }
#if($swiftBeanSupport && $column.isDate())
    /** 
     * use Long to represent date type for thrift:swift support 
     * @see #${column.getGetMethod()}()
     */
    @ThriftField(name = "$column.getVarName()",value = $fieldIndex)
    public Long ${column.getReadMethod()}(){
        return null == $column.getVarName() ? null:${column.getVarName()}.getTime();
    }
#end
#if($swiftBeanSupport && $column.isFloat())
    /** 
     * use Double to represent Float type for thrift:swift support 
     * @see #${column.getGetMethod()}()
     */
    @ThriftField(name = "$column.getVarName()",value = $fieldIndex)
    public Double ${column.getReadMethod()}(){
        return null == $column.getVarName() ? null:${column.getVarName()}.doubleValue();
    }
#end
    /**
     * Setter method for {@link #$column.getVarName()}.<br>
#if ( $column.useEqualsInSetter() )
     * The new value is set only if equals() says it is different,
     * or if one of either the new value or the current value is null.
     * In case the new value is different, it is set and the field is marked as 'modified'.
#elseif ($column.hasCompareTo())
     * The new value is set only if compareTo() says it is different,
     * or if one of either the new value or the current value is null.
     * In case the new value is different, it is set and the field is marked as 'modified'.
#else
     * Attention, there will be no comparison with current value which
     * means calling this method will mark the field as 'modified' in all cases.
#end
     *
     * @param newVal the new value#if( !$column.isAutoincrement() && $column.isNotNull())( NOT NULL)#end to be assigned to $column.getVarName()
     */
    public void $column.getSetMethod()($column.getJavaType() newVal)
    {
        checkMutable();

        $column.bitORAssignExpression("modified");
        $column.bitORAssignExpression("initialized");

#if ($column.useEqualsInSetter())
        if (Objects.equals(newVal, $column.getVarName())) {
            return;
        }
#elseif ($column.hasCompareTo())
        if (equals(newVal, $column.getVarName())) {
            return;
        }
#end
#if ( $column.hasPrimaryType() && $codewriter.getProperty('bean.compatible_axis2') )
#if($column.getJavaType()=='Integer')
        //compatible for axis2
        $column.getVarName() = null==newVal||newVal==Integer.MIN_VALUE?null:newVal;
#elseif($column.getJavaType()=='Long')
        //compatible for axis2
        $column.getVarName() = null==newVal||newVal==Long.MIN_VALUE?null:newVal;
#elseif($column.getJavaType()=='Byte')
        //compatible for axis2
        $column.getVarName() = null==newVal||newVal==Byte.MIN_VALUE?null:newVal;
#elseif($column.getJavaType()=='Double')
        //compatible for axis2
        $column.getVarName() = null==newVal||newVal==Double.MIN_VALUE?null:newVal;
#elseif($column.getJavaType()=='Float')
        //compatible for axis2
        $column.getVarName() = null==newVal||newVal==Float.MIN_VALUE?null:newVal;
#elseif($column.getJavaType()=='Character')
        //compatible for axis2
        $column.getVarName() = null==newVal||newVal==Character.MIN_VALUE?null:newVal;
#elseif($column.getJavaType()=='Short')
        //compatible for axis2
        $column.getVarName() = null==newVal||newVal==Short.MIN_VALUE?null:newVal;
#elseif($column.getJavaType()=='Boolean')
        //compatible for axis2
        $column.getVarName() = null==newVal||newVal==Boolean.FALSE?null:newVal;       
#else
        $column.getVarName() = newVal;
#end
#else
        $column.getVarName() = newVal;
#end###if ( $column.hasPrimaryType() && $codewriter.getProperty('bean.compatible_axis2') )
    }
################ SETTER METHOD FOR SWIFT ###############
#if($swiftBeanSupport)
    /** 
     * setter for thrift:swift support<br>
     * without modification for {@link ${esc.hash}modified} and {@link ${esc.hash}initialized}<br>
     * <b>NOTE:</b>DO NOT use the method in your code
     */
#if($column.isDate())
    @ThriftField(name = "$column.getVarName()")
    public void ${column.getWriteMethod()}(Long newVal){
        checkMutable();
        $column.getVarName() = null == newVal?null:new ${column.getJavaType()}(newVal);
    }
#elseif($column.isFloat())
    @ThriftField(name = "$column.getVarName()")
    public void ${column.getWriteMethod()}(Double newVal){
        checkMutable();
        $column.getVarName() = null == newVal?null:newVal.floatValue();
    }
#else
    @ThriftField(name = "$column.getVarName()")
    public void $column.getWriteMethod()($column.getJavaType() newVal){
        checkMutable();
        $column.getVarName() = newVal;
    }
#end
#end###if($swiftBeanSupport)
#if ( $column.hasPrimaryType() )
    /**
     * Setter method for {@link #$column.getVarName()}.<br>
     * Convenient for those who do not want to deal with Objects for primary types.
     *
     * @param newVal the new value to be assigned to $column.getVarName()
     */
    public void $column.getSetMethod()($column.getJavaPrimaryType() newVal)
    {
        $column.getSetMethod()(new $column.getJavaType()(newVal));
    }
#if($column.isDate())
    /**
     * Setter method for {@link ${esc.hash}$column.getVarName()}.<br>
     * @param newVal the number of milliseconds since January 1, 1970, 00:00:00 GMT represented by this Date object.
     */
    public void $column.getSetMethod()(Long newVal)
    {
        $column.getSetMethod()(null == newVal ? null : new $column.getJavaType()(newVal));
    }
#end
#end
    /**
     * Determines if the $column.getVarName() has been modified.
     *
     * @return true if the field has been modified, false if the field has not been modified
     */
    public boolean ${column.getModifiedMethod()}()
    {
        return 0L !=  ${column.bitAndExpression("modified")};
    }

    /**
     * Determines if the $column.getVarName() has been initialized.<br>
     *
     * It is useful to determine if a field is null on purpose or just because it has not been initialized.
     *
     * @return true if the field has been initialized, false otherwise
     */
    public boolean ${column.getInitializedMethod()}()
    {
        return 0L !=  ${column.bitAndExpression("initialized")};
    }
#end
##########################################
#foreach ($foreignTable in $foreignTables)
#if ( $velocityCount == 1 )
    //////////////////////////////////////
    // referenced bean for FOREIGN KEYS
    //////////////////////////////////////
#end
#set ( $foreignClass = "$foreignTable.asBeanClass($isGeneral)" )
#set ( $foreignClassManager = "$foreignTable.asManagerClass()" )
#foreach( $fkName in $table.getFkMapNames($foreignTable.name) )
#set ( $columnsOfFk = $table.getForeignKeysByFkName($fkName) )
#set ( $referencedBean = $table.getReferencedVarName($fkName) )
    /** 
     * The referenced {@link $foreignClass} by #join($columnsOfFk "{@link #$e.getVarName()}" ",") . <br>
     * FOREIGN KEY (#join($columnsOfFk "$e.name" ",")) REFERENCES ${foreignTable.name}(#join($columnsOfFk "$e.getForeignColumn().name" ","))
     */
    private $foreignClass $referencedBean;
    /**
     * Getter method for {@link #${referencedBean}}.
     * @return $foreignClass
     */
    public $foreignClass $table.getReferencedVarGetMethod($fkName)() {
        return this.$referencedBean;
    }
    /**
     * Setter method for {@link #${referencedBean}}.
     * @param reference $foreignClass
     */
    public void $table.getReferencedVarSetMethod($fkName)($foreignClass reference) {
        this.$referencedBean = reference;
    }
#end        
#end

    @Override
    public boolean isModified()
    {
#if( $table.countColumns() > 64 )
        for( long m: modified )if( 0 != m )return true;
        return false;
#else
        return 0 != modified;
#end
    }
  
    @Override
    public boolean isModified(int columnID){
        switch ( columnID ){
#foreach ( $column in $columns )
        case $column.getIDConstName():
            return ${column.getModifiedMethod()}();
#end
        default:
            return false;
        }        
    }

    @Override
    public boolean isInitialized(int columnID){
        switch(columnID) {
#foreach ( $column in $columns )
        case $column.getIDConstName():
            return ${column.getInitializedMethod()}();
#end
        default:
            return false;
        }
    }
    
    @Override
    public boolean isModified(String column){        
        return isModified(columnIDOf(column));
    }

    @Override
    public boolean isInitialized(String column){
        return isInitialized(columnIDOf(column));
    }
    
    @Override
    public void resetIsModified()
    {
        checkMutable();
#if( $table.countColumns() > 64 )
        java.util.Arrays.fill(modified,0L);
#else
        modified = 0L;
#end
    }

    @Override
    public void resetPrimaryKeysModified()
    {
        $table.bitResetAssignExpression($primaryKeys,"modified",'            ');
    }
    /**
     * Resets columns modification status except primary keys to 'not modified'.
     */
    public void resetModifiedExceptPrimaryKeys()
    {
        $table.bitResetAssignExpression($table.getColumnsExceptPrimary(),"modified",'            ');
    }
    /**
     * Resets the object initialization status to 'not initialized'.
     */
    private void resetInitialized()
    {
#if( $table.countColumns() > 64 )
        java.util.Arrays.fill(initialized,0L);
#else
        initialized = 0L;
#end
    }
    /** reset all fields to initial value, equal to a new bean */
    public void reset(){
        checkMutable();
#foreach($column in $columns)
#if($column.originalDefaultValue)
### Default value ÐÐ×¢ÊÍ 
        $!{column.commentOfDefaultValue()}
#end
        this.$column.getVarName()${column.getDefaultValueAssignment(true)};
#end
        this.isNew = true;
        this.modified = $table.maskInitializeWithZero();
        this.initialized = $table.maskInitializeWithDefaultValue();
    }
    @Override
    public boolean equals(Object object)
    {
        if (!(object instanceof ${beanClass})) {
            return false;
        }

        $beanClass obj = ($beanClass) object;
        return new EqualsBuilder()
#foreach ( $column in $columns )
            .append(${column.getGetMethod()}(), obj.${column.getGetMethod()}())
#end
            .isEquals();
    }

    @Override
    public int hashCode()
    {
#if($table.hasPrimaryKey())
#set ($hashColumns = $primaryKeys)
#else
#set ($hashColumns = $columns)
#end
        return new HashCodeBuilder(-82280557, -700257973)
#foreach ( $column in $hashColumns )
            .append(${column.getGetMethod()}())
#end
            .toHashCode();
    }

    @Override
    public String toString() {
        return toString(true,false);
    }
    /**
     * cast byte array to HEX string
     * 
     * @param input
     * @return {@code null} if {@code input} is null
     */
    private static final String toHex(byte[] input) {
        if (null == input){
            return null;
        }
        StringBuffer sb = new StringBuffer(input.length * 2);
        for (int i = 0; i < input.length; i++) {
            sb.append(Character.forDigit((input[i] & 240) >> 4, 16));
            sb.append(Character.forDigit(input[i] & 15, 16));
        }
        return sb.toString();
    }
    protected static final StringBuilder append(StringBuilder buffer,boolean full,byte[] value){
        if(full || null == value){
            buffer.append(toHex(value));
        }else{
            buffer.append(value.length).append(" bytes");
        }
        return buffer;
    }
    private static int stringLimit = 64;
    private static final int MINIMUM_LIMIT = 16;
    protected static final StringBuilder append(StringBuilder buffer,boolean full,String value){
        if(full || null == value || value.length() <= stringLimit){
            buffer.append(value);
        }else{
            buffer.append(value.substring(0,stringLimit - 8)).append(" ...").append(value.substring(stringLimit-4,stringLimit));
        }
        return buffer;
    }
    protected static final <T>StringBuilder append(StringBuilder buffer,boolean full,T value){
        return buffer.append(value);
    }
    public static final void setStringLimit(int limit){
        if(limit < MINIMUM_LIMIT){
            throw new IllegalArgumentException(String.format("INVALID limit %d,minimum value %d",limit,MINIMUM_LIMIT));
        }
        stringLimit = limit;
    }
    @Override
    public String toString(boolean notNull, boolean fullIfStringOrBytes) {
        // only output initialized field
        StringBuilder builder = new StringBuilder(this.getClass().getName()).append("@").append(Integer.toHexString(this.hashCode())).append("[");
        int count = 0;        
#foreach ( $column in $columns )
        if(${column.getInitializedMethod()}()){
            if(!notNull || null != ${column.getGetMethod()}()){
                if(count++ >0){
                    builder.append(",");
                }
                builder.append("$column.getName()=");
                append(builder,fullIfStringOrBytes,${column.getGetMethod()}());
            }
        }
#end
        builder.append("]");
        return builder.toString();
    }
    @Override
    public int compareTo($beanClass object){
        return new CompareToBuilder()
#foreach ( $column in $columns )
            .append(${column.getGetMethod()}(), object.${column.getGetMethod()}())
#end
            .toComparison();
    }
    @Override
    public $beanClass clone(){
        try {
            return ($beanClass) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }
################## NULL BEAN ###########
    /**
     * Make {@code this} to a NULL bean<br>
     * set all fields to null, {@link ${esc.hash}modified} and {@link ${esc.hash}initialized} be set to 0
     * @return {@code this} bean
     * @author guyadong
     */
    public ${beanClass} asNULL()
    {   
        checkMutable();
        #join($columns '
        $e.getSetMethod()(($e.javaType)null);' '')

        isNew(true);
        resetInitialized();
        resetIsModified();
        return this;
    }
    /**
     * check whether this bean is a NULL bean 
     * @return {@code true} if {@link ${esc.hash}initialized} be set to zero
     * @see ${esc.hash}asNULL()
     */
    public boolean checkNULL(){
#if($table.countColumns()>64)
        return isAllZero(getInitialized()) && isAllZero(getModified());
#else
        return 0L == getInitialized();
#end
    }
    /** 
     * @param source source list
     * @return {@code source} replace {@code null} element with null instance({@link ${esc.hash}NULL})
     */
    public static final List<$beanClass> replaceNull(List<$beanClass> source){
        if(null != source){
            for(int i = 0,endIndex = source.size();i<endIndex;++i){
                if(null == source.get(i)){
                    source.set(i, NULL);
                }
            }
        }
        return source;
    }
    /** 
     * @param source input list
     * @return replace null instance element with {@code null}
     * @see ${esc.hash}checkNULL()
     */
    public static final List<$beanClass> replaceNullInstance(List<$beanClass> source){
        if(null != source){
            for(int i = 0,endIndex = source.size();i<endIndex;++i){
                if(source.get(i).checkNULL()){
                    source.set(i, null);
                }
            }
        }
        return source;
    }
#if($table.countColumns()>64)
    private static final boolean isAllZero(long[] array){
        for(long e : array)if(0L != e)return false;
        return true;
    }
#end
############################################
    @Override
    public ${beanClass} copy(${beanClass} bean)
    {
        return copy(bean,new int[]{});
    }
    @Override
    public ${beanClass} copy(${beanClass} bean, int... fieldList)
    {
        if (null == fieldList || 0 == fieldList.length){
            for (int i = 0; i < ${table.name.toUpperCase()}_COLUMN_COUNT; ++i) {
                if( bean.isInitialized(i)){
                    setValue(i, bean.getValue(i));
                }
            }
        }
        else{
            for (int i = 0; i < fieldList.length; ++i) {
                if( bean.isInitialized(fieldList[i])){
                    setValue(fieldList[i], bean.getValue(fieldList[i]));
                }
            }
        }
        return this;
    }
        
    @Override
    public ${beanClass} copy(${beanClass} bean, String... fieldList)
    {
        if (null == fieldList || 0 == fieldList.length){
            copy(bean,(int[])null);
        }else{
            int field;
            for (int i = 0; i < fieldList.length; i++) {
                field = columnIDOf(fieldList[i].trim());
                if(bean.isInitialized(field)){
                    setValue(field, bean.getValue(field));
                }
            }
        }
        return this;
    }

    @SuppressWarnings("unchecked")
    @Override
    public <T>T getValue(int columnID)
    {
        switch( columnID ){
#foreach ( $column in $columns )
        case $column.getIDConstName(): 
            return (T)${column.getGetMethod()}();        
#end
        default:
            return null;
        }
    }

    @Override
    public <T> void setValue(int columnID,T value)
    {
        switch( columnID ) {
#foreach ( $column in $columns )
        case $column.getIDConstName():
            ${column.getSetMethod()}(($column.getJavaType())value);
            break;
#end
        default:
            break;
        }
    }
    
    @Override
    public <T> T getValue(String column)
    {
        return getValue(columnIDOf(column));
    }

    @Override
    public <T> void setValue(String column,T value)
    {
        setValue(columnIDOf(column),value);
    }
    
    /**
     * @param column column name
     * @return column id for the given field name or negative if {@code column} is invalid name 
     */
    public static int columnIDOf(String column){
        int index = ${table.name.toUpperCase()}_FIELDS_LIST.indexOf(column);
        return  index < 0 
            ? ${table.name.toUpperCase()}_JAVA_FIELDS_LIST.indexOf(column)
            : index;
    }
    
    public static final Builder builder(){
        return new Builder();
    }
    /** 
     * a builder for $beanClass,the template instance is thread local variable
     * a instance of Builder can be reused.
     */
    public static final class Builder{
        /** $beanClass instance used for template to create new $beanClass instance. */
        static final ThreadLocal<$beanClass> TEMPLATE = new ThreadLocal<$beanClass>(){
            @Override
            protected $beanClass initialValue() {
                return new ${beanClass}();
            }};
        private Builder() {}
        /** 
         * reset the bean as template 
         * @see ${beanClass}${esc.hash}reset()
         */
        public Builder reset(){
            TEMPLATE.get().reset();
            return this;
        }
        /** set a bean as template,must not be {@code null} */
        public Builder template($beanClass bean){
            if(null == bean){
                throw new NullPointerException();
            }
            TEMPLATE.set(bean);
            return this;
        }
        /** return a clone instance of {@link ${esc.hash}TEMPLATE}*/
        public $beanClass build(){
            return TEMPLATE.get().clone();
        }
#foreach($column in $columns)
        /** 
         * fill the field : $column.fullName
         * @param $column.varName $!{column.remarks}
         * @see $beanClass${esc.hash}${column.getGetMethod()}()
         * @see $beanClass${esc.hash}${column.getSetMethod()}($column.javaType)
         */
        public Builder ${column.varName}($column.javaType $column.varName){
            TEMPLATE.get().${column.getSetMethod()}($column.varName);
            return this;
        }
#end
    }
####### FOR EXTENSION ##############
#parse( $codewriter.getProperty("template.extension.bean"))
}
