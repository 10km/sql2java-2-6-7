#parse( "header.include.vm" )
#parse( "schema.include.vm" )
#if($isAsync)
#set ($asyncSuffix = 'Async')
#set ($asyncComment = '(asynchronous implementation)')
#else
#set ($asyncSuffix = $null)
#set ($asyncComment = $null)
#end
#if(!$codewriter.existsDependencyPackage() || !$codewriter.existsDependencySrc())
$codewriter.setSaveCurrentFile(false);
#stop
#end
#set ($swiftParser = $codewriter.loadExtensionClass("gu.rpc.thrift.SwiftServiceParser").newInstance())
#set ($typeUtils = $codewriter.loadExtensionClass("gu.rpc.thrift.TypeUtils").newInstance())
#set ($javadocReader = $codewriter.loadExtensionClass("gu.doc.JavadocReader").newInstance())
#set ($serviceSrcDir = $codewriter.getProperty("swift.service.source"))
#set ($nothing = $typeUtils.setPackagePrefix("net.gdface.facelog.db"))
## $bean$用于替换beanClass
#set ($nothing = $typeUtils.setConvertVar('converter$bean$'))
#set ($nothing = $typeUtils.setToBytesMethodPrefix("toBytes"))
#set ($classpath = $codewriter.getPropertyExploded("swift.service.classpath"))
#set ($metadata = $swiftParser.parse('net.gdface.facelog.FaceLogDefinition',$classpath))
#set ($serviceSourceFile = $codewriter.getSourceFile($serviceSrcDir,$swiftParser.serviceClass))
#set ($serviceComment    = $javadocReader.read($serviceSourceFile))
## disable to show @throws tag
#set ( $thriftSrc = $codewriter.getProperty("dependency.src"))
#set ( $thriftPackage = $codewriter.getProperty("dependency.package"))
#set ( $serviceName = ${metadata.name} )
## 删除原注释中的 @throws 标记
#set ($nothing = $serviceComment.addExcludeTag("@throws"))
## 修改注释
#set ($nothing = $serviceComment.additionalText("remote implementation of the service $serviceName$!asyncComment<br>
all comment copied from {@code ${swiftParser.serviceClass.name}.java}<br>","OVERWRITE","CLASS"))
#set ( $javaClassName = "${serviceName}Client$!asyncSuffix" )
$codewriter.setCurrentJavaFilename("${gpkg}", "${javaClassName}.java")
package ${gpkg};
#macro( convertVar $c)converter$c#end
import com.google.common.collect.Maps;
import com.google.common.collect.Maps.EntryTransformer;
#if($isAsync)
import com.google.common.util.concurrent.Futures;
import com.google.common.util.concurrent.ListenableFuture;
#end
import static com.google.common.base.Preconditions.checkNotNull;
import java.nio.ByteBuffer;
import java.util.*;
#macro( convertVar $c)converter$c#end
#macro( eachDepencyTable $do $separator)
#set ( $m_count = 0 )
#foreach($table in $tables)
#set ( $leftClass  = "${table.asBeanClassNSP()}" )
#if($codewriter.existsInDependencyPackage($leftClass))
#set ( $m_count = $m_count + 1 )
#set ( $rightClass = "${codewriter.getDependencyPackage()}.${leftClass}" )#if( $m_count > 1 )$!separator#end#evaluate($do)#end
#end
#end
#define($interfaceClass)${thriftPackage}.${serviceName}#if($isAsync).$asyncSuffix#end#end
$!{serviceComment.getClassComment()}
class $javaClassName implements Constant{
## 从properties 文件中读取converter的初始化代码
#set ( $converterInit = $codewriter.getProperty('swift.service.converter.init'))
    #eachDepencyTable("
    /** bean converter between {@link $leftClass} and corresponding thrift bean */
    private IBeanConverter<$leftClass,$rightClass> #convertVar(${leftClass}) $!converterInit;" $null)
## 如果properties 文件中没有指定初始化代码,就生成getter/setter方法
#if(!$converterInit)
#eachDepencyTable('
    /** 
     * @return converter of $leftClass 
     */
    public IBeanConverter<$leftClass,$rightClass> get${leftClass}Converter(){
        return #convertVar(${leftClass});
    }
    /** 
     * setup converter of $leftClass 
     * @param #convertVar(${leftClass}) must not be null. 
     */
    public void set${leftClass}Converter(IBeanConverter<$leftClass,$rightClass> #convertVar(${leftClass})){
        if(null == #convertVar(${leftClass}))
            throw new NullPointerException();
        this.#convertVar(${leftClass}) = #convertVar(${leftClass});
    }' $null)
#end##(!$converterInit)
    private final $interfaceClass service;
    /**
     * constructor 
     * @param service a instance of ${interfaceClass} created by Swift, must not be null
     */
    $javaClassName(${interfaceClass} service){
        checkNotNull(service,"service is null");
        this.service = service;
    }
    protected static final byte[] toBytes(ByteBuffer buffer){
        if(null == buffer)return null;
        int pos = buffer.position();
        try{
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            return bytes;
        }finally{
            buffer.position(pos);
        }
    }
    private static final CollectionUtils.DualTransformer<ByteBuffer,byte[]> dualTransformer = new CollectionUtils.DualTransformer<ByteBuffer,byte[]>(){
        @Override
        public byte[] toRight(ByteBuffer input) {
            return toBytes(input);
        }
        @Override
        public ByteBuffer fromRight(byte[] input) {
            return null == input ? null : ByteBuffer.wrap(input);
        }};
    /** get a view of Map<ByteBuffer,V> with {@code byte[]} key type */
    protected static final<V>Map<byte[],V> toBytesKey(Map<ByteBuffer,V> source){
        if(null == source)return null;
        return CollectionUtils.tranformKeys(source, dualTransformer);
    }
    private static final EntryTransformer<Object,ByteBuffer,byte[]> transformer = new EntryTransformer<Object,ByteBuffer,byte[]>(){
        @Override
        public byte[] transformEntry(Object key, ByteBuffer value) {
             return dualTransformer.toRight(value);
        }};
    /** get a view of Map<K,ByteBuffer> with {@code byte[]} value type */
    protected static final<K> Map<K,byte[]> toBytesValue(Map<K,ByteBuffer> source){
        if(null == source)return null;
        return Maps.transformEntries(source, transformer);
    }
#foreach($method in $sorter.sort($metadata.methods.values(),"name"))
#set ($returnType = $method.returnType.javaType)
#if(!$typeUtils.isVoid($returnType) || $isAsync)
#set ( $thriftReturn = "return ")
#else
#set ( $thriftReturn = $null)
#end
#define($returnTypeStr)
#set ($tmp = $typeUtils.wrapType($returnType,$isAsync))
#if($isAsync)ListenableFuture<$tmp>#else$tmp#end#end
$!{serviceComment.getMethodComment($method.method)}
    public $returnTypeStr ${method.method.name}(#join($method.parameters '$typeUtils.swiftType($e.thriftType.javaType) $e.name' ',')){
#define( $callThrift )service.${method.name}(#join($method.parameters '$typeUtils.toRight(${e.thriftType.javaType}, $e.name)' ',
                '))#end
#if($typeUtils.isTypeOfDao($returnType))
#if($isAsync)
        return Futures.transform(
                $callThrift, 
                new com.google.common.base.Function<$typeUtils.asJavaType($returnType,$thriftPackage),$typeUtils.asJavaType($returnType)>(){
                    @Override
                    public $typeUtils.asJavaType($returnType) apply($typeUtils.asJavaType($returnType,$thriftPackage) input) {
                        return $typeUtils.fromRight($returnType,"input");
                    }
                });
#else
        $!{thriftReturn}$typeUtils.fromRight($returnType,"$callThrift");
#end
#else
        $!{thriftReturn}$callThrift;
#end
    }
#end
}
