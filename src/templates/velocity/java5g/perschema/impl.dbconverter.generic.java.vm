#parse( "schema.include.vm" )
#parse( "header.include.vm" )
#parse( "macros.include.vm" )
#set ( $javaClassName = 'DbConverterGeneric' )
#set( $subpkg=$db.engineAsSubPackage() )
#set( $ignorefields= $codewriter.getProperty('general.beanconverter.tonative.ignore') )
$codewriter.setCurrentJavaFilename($gpkg, "${javaClassName}.java")
package ${gpkg};
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import ${gpkg}.IBeanConverter;
import ${gpkg}.IDbConverter;

#foreach ( $table in $tables )
import ${gpkg}.${table.asBeanClassNSP()};
#end
/**
 * generic type converter of {@link IDbConverter} implementation<br>
 * usage:<pre>new ${javaClassName}&lt;#join($tables "Model$velocityCount" ',')&gt;(){};</pre>
 * @author guyadong
 *
#foreach($table in $tables)
 * @param <R_${table.asCoreClassNSP().toUpperCase()}> native type for $table.name
#end
 *
 */
public abstract class ${javaClassName}<#join($tables "
                    R_${e.asCoreClassNSP().toUpperCase()}" ',')> 
    implements IDbConverter<#join($tables "R_${e.asCoreClassNSP().toUpperCase()}" ',')>, Constant{
#foreach ( $table in $tables )
#set ( $leftClass  = "${table.asBeanClassNSP()}" )
#set ( $rightClass = "R_${table.asCoreClassNSP().toUpperCase()}" )
    private final IBeanConverter<${leftClass},${rightClass}> ${table.asConverterVar()};
#end
    private static Class<?> getRawClass(Type type){
        if(type instanceof Class<?>){
            return (Class<?>) type;
        } else if(type instanceof ParameterizedType){
            return getRawClass(((ParameterizedType) type).getRawType());
        } else{
            throw new IllegalArgumentException("invalid type");
        }
    }
#set($vprefix = "java_fields_of_")
    /** 
     * usage: <pre>new ${javaClassName}&lt;Model...&gt;(javaFields...){};</pre>
     * each 'javaFields' parameter is a comma splice string,including all field name of right type,<br>
     * if null or empty, use default string of each table
     */
    @SuppressWarnings("unchecked")
    public ${javaClassName}(#join($tables 'String ${e.asVar($vprefix)}' ',
                    ')){
        #join($tables 'if(null == ${e.asVar($vprefix)} || ${e.asVar($vprefix)}.isEmpty())${e.asVar($vprefix)} = $e.name.toUpperCase()_JAVA_FIELDS;
        ' '')

        Type[] typeArguments = ((ParameterizedType)getClass().getGenericSuperclass()).getActualTypeArguments();
#foreach ( $table in $tables )
#set ( $leftClass  = "${table.asBeanClassNSP()}" )
#set ( $rightClass = "R_${table.asCoreClassNSP().toUpperCase()}" )
#set ( $idx = $velocityCount - 1 )
        this.${table.asConverterVar()} = new BeanConverterUtils.#converterClass(${leftClass})<${rightClass}>(${leftClass}.class,
            (Class<$rightClass>)getRawClass(typeArguments[$idx]),${table.asVar($vprefix)});            
#end
    }
    public ${javaClassName}(){
        this(#join($tables 'null' ','));
    }
    @Override
    public <L,R>IBeanConverter<L,R>getBeanConverter(Class<L> lClass,Class<R> rClass){
        throw new UnsupportedOperationException();
    }
    
    @Override
    public <L,R>void setBeanConverter(Class<L> lClass,Class<R> rClass,IBeanConverter<L,R>converter){
        throw new UnsupportedOperationException();
    }

#foreach ( $table in $tables )
#set ( $leftClass  = "${table.asBeanClassNSP()}" )
#set ( $rightClass = "R_${table.asCoreClassNSP().toUpperCase()}" )
    @Override
    public IBeanConverter<${leftClass}, ${rightClass}> get${leftClass}Converter() {
        return ${table.asConverterVar()};
    }
#end    
}
