#parse( "header.include.vm" )
#parse( "schema.include.vm" )
#set($npkg = $codewriter.getProperty('general.package') )
$codewriter.setCurrentJavaFilename("${npkg}.orm", "DbConverter.java")
package ${npkg}.orm;

import java.util.Vector;
import ${npkg}.IBeanConverter;
import ${npkg}.IDbConverter;
import ${npkg}.BaseBean;

#foreach ( $table in $tables )
import ${npkg}.${table.asBeanClassNSP()};
#end
#foreach ( $table in $tables )
import ${table.getPackage()}.${table.asBeanClass()}Base;
#end
#macro( convertVar $c)_convert$c#end
public class DbConverter implements IDbConverter {
#foreach ( $table in $tables )
    public final IBeanConverter<${table.asBeanClassNSP()},${table.asBeanClass()}Base> #convertVar(${table.asBeanClassNSP()})=new IBeanConverter.AbstractHandle<${table.asBeanClassNSP()},${table.asBeanClass()}Base>(){

        @Override
        public ${table.asBeanClassNSP()} fromNative(${table.asBeanClass()}Base bean) {
            return null;
        }

        @Override
        public ${table.asBeanClass()}Base toNative(${table.asBeanClassNSP()} bean) {
            return null;
        }};
#end

    private final Vector<Object[]> converters= new Vector<Object[]>(){
        private static final long serialVersionUID = -2915982403974349774L;
        {
#foreach ( $table in $tables )
            add(new Object[]{${table.asBeanClassNSP()}.class,${table.asBeanClass()}Base.class,#convertVar(${table.asBeanClassNSP()})});
#end
        }};
    
    private<G extends BaseBean,N> int getIndex(Class<G> gClass,Class<N> nClass){
            Vector<Integer>find= new Vector<Integer>();
            if(null!=gClass && null != nClass){
                for(int i=0;i<converters.size();++i){
                    Object[] converter = converters.get(i);
                    if(((Class<?>)converter[0]).isAssignableFrom(gClass) 
                            && ((Class<?>)converter[1]).isAssignableFrom(nClass)){
                        return i;
                    }
                }
            }else if(null != gClass){
                for(int i=0;i<converters.size();++i){
                    Object[] converter = converters.get(i);
                    if(((Class<?>)converter[0]).isAssignableFrom(gClass) 
                            ){
                        find.add(i);
                    }
                }
            }else if(null != nClass){
                for(int i=0;i<converters.size();++i){
                    Object[] converter = converters.get(i);
                    if(((Class<?>)converter[1]).isAssignableFrom(nClass)){
                        find.add(i);
                    }
                }
            }
            return  1==find.size() ? find.get(0) : -1;
        }  
    @Override
    @SuppressWarnings("unchecked")
    public <G extends BaseBean,N>IBeanConverter<G,N>getBeanConverter(Class<G> gClass,Class<N> nClass){
        int index = getIndex(gClass, nClass);
        if(index<0)
            throw new IllegalArgumentException(
                    String.format("not found converter for (%s,%s)"
                            ,null==gClass?"null":gClass.getSimpleName()
                            ,null==nClass?"null":nClass.getSimpleName()));
        return (IBeanConverter<G, N>) converters.get(index)[2];
    }
    @Override
    public synchronized <G extends BaseBean,N>void setBeanConverter(Class<G> gClass,Class<N> nClass,IBeanConverter<G,N>converter){
        if(null == gClass || null == nClass || null == converter)
            throw new NullPointerException();
        Object[] c = new Object[]{gClass,nClass,converter};
        int index = getIndex(gClass, nClass);
        if(index<0){
            converters.add(c);
        }else{
            converters.set(index, c);
        }
    }
#foreach ( $table in $tables )

    @Override
    public IBeanConverter<${table.asBeanClassNSP()}, ${table.asBeanClass()}Base> get${table.asBeanClassNSP()}Converter() {
        return #convertVar(${table.asBeanClassNSP()});
    }
#end    
}
