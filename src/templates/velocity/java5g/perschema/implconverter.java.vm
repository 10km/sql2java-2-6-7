#parse( "header.include.vm" )
#parse( "schema.include.vm" )
#set( $gpkg = $codewriter.getProperty('general.package') )
#set( $subpkg=$db.engineAsSubPackage() )
#set( $ignorefields= $codewriter.getProperty('general.beanconverter.tonative.ignore') )
$codewriter.setCurrentJavaFilename("${gpkg}.${subpkg}", "DbConverter.java")
package ${gpkg}.${subpkg};

import java.util.Vector;
import ${gpkg}.IBeanConverter;
import ${gpkg}.IDbConverter;
import ${gpkg}.BaseBean;

#foreach ( $table in $tables )
import ${gpkg}.${table.asBeanClassNSP()};
#end
#foreach ( $table in $tables )
import ${table.getPackage()}.${table.asBeanClass()}Base;
#end
#macro( convertVar $c)_converter$c#end
public class DbConverter implements IDbConverter {
#foreach ( $table in $tables )
    public final IBeanConverter<${table.asBeanClassNSP()},${table.asBeanClass()}Base> #convertVar(${table.asBeanClassNSP()})=new IBeanConverter.AbstractHandle<${table.asBeanClassNSP()},${table.asBeanClass()}Base>(){

        @Override
        public ${table.asBeanClassNSP()} fromNative(${table.asBeanClass()}Base bean) {
            ${table.asBeanClassNSP()} generalBean= new ${table.asBeanClassNSP()}();
            generalBean.isNew(bean.isNew());
#foreach ( $column in $table.columns )
            if(bean.${column.getGetMethod()}() != null)
                generalBean.$column.getSetMethod()(bean.${column.getGetMethod()}());
#end
            return generalBean;
        }

        @Override
        public ${table.asBeanClass()}Base toNative(${table.asBeanClassNSP()} bean) {
            ${table.getPackage()}.${table.asBeanClass()} nativeBean= new ${table.getPackage()}.${table.asBeanClass()}();
            nativeBean.isNew(bean.isNew());
#foreach ( $column in $table.columns )
#if( $ignorefields.contains($column.name) )// ignore field $column.name
#end
#if( $ignorefields.contains($column.name) )// #end            if(bean.${column.getGetMethod()}() != null)
#if( $ignorefields.contains($column.name) )// #end                nativeBean.$column.getSetMethod()(bean.${column.getGetMethod()}());

#end
            return nativeBean;
        }};
        
#end

    private final Vector<Object[]> converters= new Vector<Object[]>(){
        private static final long serialVersionUID = -2915982403974349774L;
        {
#foreach ( $table in $tables )
            add(new Object[]{${table.asBeanClassNSP()}.class,${table.asBeanClass()}Base.class,#convertVar(${table.asBeanClassNSP()})});
#end
        }};
    
    private<G extends BaseBean,N> int getIndex(Class<G> gClass,Class<N> nClass){
            Vector<Integer>find= new Vector<Integer>();
            if(null!=gClass && null != nClass){
                for(int i=0;i<converters.size();++i){
                    Object[] converter = converters.get(i);
                    if(((Class<?>)converter[0]).isAssignableFrom(gClass) 
                            && ((Class<?>)converter[1]).isAssignableFrom(nClass)){
                        return i;
                    }
                }
            }else if(null != gClass){
                for(int i=0;i<converters.size();++i){
                    Object[] converter = converters.get(i);
                    if(((Class<?>)converter[0]).isAssignableFrom(gClass) 
                            ){
                        find.add(i);
                    }
                }
            }else if(null != nClass){
                for(int i=0;i<converters.size();++i){
                    Object[] converter = converters.get(i);
                    if(((Class<?>)converter[1]).isAssignableFrom(nClass)){
                        find.add(i);
                    }
                }
            }
            return  1==find.size() ? find.get(0) : -1;
        }  
    @Override
    @SuppressWarnings("unchecked")
    public <G extends BaseBean,N>IBeanConverter<G,N>getBeanConverter(Class<G> gClass,Class<N> nClass){
        int index = getIndex(gClass, nClass);
        if(index<0)
            throw new IllegalArgumentException(
                    String.format("not found converter for (%s,%s)"
                            ,null==gClass?"null":gClass.getSimpleName()
                            ,null==nClass?"null":nClass.getSimpleName()));
        return (IBeanConverter<G, N>) converters.get(index)[2];
    }
    @Override
    public synchronized <G extends BaseBean,N>void setBeanConverter(Class<G> gClass,Class<N> nClass,IBeanConverter<G,N>converter){
        if(null == gClass || null == nClass || null == converter)
            throw new NullPointerException();
        Object[] c = new Object[]{gClass,nClass,converter};
        int index = getIndex(gClass, nClass);
        if(index<0){
            converters.add(c);
        }else{
            converters.set(index, c);
        }
    }
#foreach ( $table in $tables )

    @Override
    public IBeanConverter<${table.asBeanClassNSP()}, ${table.asBeanClass()}Base> get${table.asBeanClassNSP()}Converter() {
        return #convertVar(${table.asBeanClassNSP()});
    }
#end    
}
