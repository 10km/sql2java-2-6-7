#parse( "schema.include.vm" )
#parse( "header.include.vm" )
#parse( "macros.include.vm" )
#set ( $javaClassName = 'BeanConverterUtils' )
#set( $subpkg=$db.engineAsSubPackage() )
#set( $ignorefields= $codewriter.getProperty('general.beanconverter.tonative.ignore') )
$codewriter.setCurrentJavaFilename($gpkg, "${javaClassName}.java")
package ${gpkg};
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.util.Map;
import java.util.Hashtable;
import ${gpkg}.IBeanConverter;

#foreach ( $table in $tables )
import ${gpkg}.${table.asBeanClassNSP()};
#end

/**
 * generic type converter classes of {@link IBeanConverter} implementation for #join($tables "$e.name" ',')<br>
 * @author guyadong
 *
 */
public class ${javaClassName} implements Constant {
    private ${javaClassName}(){}
    /**
     * 返回buffer中所有字节(position~limit),不改变buffer状态
     * @param buffer
     * @return
     */
    private static final byte[] getBytesInBuffer(ByteBuffer buffer){
        int pos = buffer.position();
        try{
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            return bytes;
        }finally{
            buffer.position(pos);
        }
    }
    /**
     * {@code obj}转为{@code type}指定的类型
     * @param type
     * @param obj
     * @return
     */
    @SuppressWarnings({ "unchecked" })
    private static final <T> T convert(Class<T> type,Object obj){
        try{
            if(null ==obj && type.isPrimitive())
                throw new IllegalArgumentException(String.format("can't convert null to primitive type %s",type.getSimpleName()));
            return (T) obj;
        }catch(ClassCastException ce){
            // Long -> Date
            if(java.util.Date.class.isAssignableFrom(type) && (obj instanceof Long)){
                try {
                    // call constructor,such as  java.util.Date#Date(long), java.sql.Time.Time(long)
                    return type.getConstructor(long.class).newInstance(obj);
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
            // Date -> Long,long
            if( (long.class == type || Long.class == type) && obj instanceof java.util.Date){
                	Long time = ((java.util.Date)obj).getTime();
                    return (T)time;
            }
            // byte[] -> ByteBuffer
            if(ByteBuffer.class == type && obj instanceof byte[]){
                return (T) ByteBuffer.wrap((byte[]) obj);
            }
            // ByteBuffer -> byte[]
            if(byte[].class == type && obj instanceof ByteBuffer){
                return (T) getBytesInBuffer((ByteBuffer) obj);
            }
            throw new IllegalArgumentException(String.format("can't convert %s to %s",obj.getClass().getSimpleName(),type.getSimpleName()));
        }
    }
    private static final boolean bitCheck(int index,long...bits){
    	return 0 != (bits[index>>6]&(1L<<(index&0x3f)));
    }
    private static final long[] bitOR(int index,long... bits){
    	 bits[index>>6] |= (1L<<(index&0x3f));
    	 return bits;
    }
#foreach ( $table in $tables )
#set ( $leftClass  = "${table.asBeanClassNSP()}" )
#set ( $rightClass = "N_${table.asCoreClassNSP().toUpperCase()}" )
    /**
     * implementation of {@link IBeanConverter} by reflect<br>
     * generic type converter for {@link $leftClass} to $rightClass <br>
     * @author guyadong
     *
     */
    public static class #converterClass(${leftClass})<$rightClass> extends IBeanConverter.AbstractHandle<${leftClass},${rightClass}>{
        private final Map<String,Method> methods = new Hashtable<String,Method>();
        private final Map<String,Integer> rightIndexs = new Hashtable<String,Integer>();
        private String[] rightFields;
        private boolean bitCheck(String name,long...bits){
        	Integer id = rightIndexs.get(name);
        	return (null == id)?false:BeanConverterUtils.bitCheck(id.intValue(),bits);
        }
        private long[] bitOR(String name,long... bits){
            return BeanConverterUtils.bitOR(rightIndexs.get(name),bits);
        }
        /** usage: <pre>new #converterClass(${leftClass})&lt;Model&gt;(){};</pre> */
        public #converterClass(${leftClass})(String javaFields){
            super();
            init(javaFields);
        }
        public #converterClass(${leftClass})(){
            this(null);
        }
        public #converterClass(${leftClass}) (Class<${leftClass}> leftClass, Class<N_${table.asCoreClassNSP().toUpperCase()}> rightClass,String javaFields){
            super(leftClass,rightClass);
            init(javaFields);
        }
        public #converterClass(${leftClass}) (Class<${leftClass}> leftClass, Class<N_${table.asCoreClassNSP().toUpperCase()}> rightClass){
            this(leftClass,rightClass,null);
        }
        private void init(String javaFields){
            if(null == javaFields){
                javaFields = $table.name.toUpperCase()_JAVA_FIELDS;
            }
            rightFields = javaFields.split(",");
            for(int i = 0 ; i < rightFields.length; ++i)
                rightIndexs.put(rightFields[i],i);
            try{
                methods.put("isNew",rightType.getMethod("isNew"));
                methods.put("setNew",rightType.getMethod("setNew",boolean.class));
                methods.put("getModified",rightType.getMethod("getModified"));
                methods.put("setModified",rightType.getMethod("setModified",${table.stateVarType()}.class));
            }catch(RuntimeException e){
                throw e;
            }catch(Exception e){
                throw new RuntimeException(e);
            }
#foreach ( $column in $table.columns )  
            try{         
                methods.put("${column.getGetMethod()}",rightType.getMethod("${column.getGetMethod()}"));
#if ( $column.hasPrimaryType())
                try{
                    methods.put("${column.getSetMethod()}",rightType.getMethod("${column.getSetMethod()}",${column.getJavaType()}.class));
                }catch(NoSuchMethodException nm){
#if($column.isDate())
                    try{
                        methods.put("${column.getSetMethod()}",rightType.getMethod("${column.getSetMethod()}",${column.getJavaPrimaryType()}.class));
                    }catch(NoSuchMethodException nm2){
                        methods.put("${column.getSetMethod()}",rightType.getMethod("${column.getSetMethod()}",Long.class));
                    }
#else
                    methods.put("${column.getSetMethod()}",rightType.getMethod("${column.getSetMethod()}",${column.getJavaPrimaryType()}.class));
#end
                }
#else
                methods.put("${column.getSetMethod()}",rightType.getMethod("${column.getSetMethod()}",${column.getJavaType()}.class));
#end
            }catch(Exception e){}
#end
        }
        @Override
        protected void _fromRight(${leftClass} left, ${rightClass} right) {
            try{
                Method getterMethod;
                left.resetIsModified();
                long[] modified;
                if(rightFields.length > 64)
                    modified = (long[])methods.get("getModified").invoke(right);
                else
                    modified = new long[]{(long)methods.get("getModified").invoke(right)};
#foreach ( $column in $table.columns )
                if( bitCheck("$column.getJavaName()",modified) && (null != (getterMethod = methods.get("${column.getGetMethod()}"))))
                    left.$column.getSetMethod()(convert(${column.getJavaType()}.class,getterMethod.invoke(right)));
#end
                left.isNew((boolean)methods.get("isNew").invoke(right));
            }catch(RuntimeException e){
                throw e;
            }catch(Exception e){
                throw new RuntimeException(e);
            }
        }

        @Override
        protected void _toRight(${leftClass} left, ${rightClass} right) {
            try{
                Method setterMethod;
                long[] modified = new long[(rightFields.length + 63)>>6];
                for(int i = 0 ;i < modified.length; ++i)modified[i] = 0L;
#foreach ( $column in $table.columns )
#if( $ignorefields.contains($column.name) )// IGNORE field $column.fullName , controlled by 'general.beanconverter.tonative.ignore' in properties file
#end
#if( $ignorefields.contains($column.name) )// #end                if(null != (setterMethod = methods.get("$column.getSetMethod()")) && left.${column.getInitializedMethod()}()){
#if( $ignorefields.contains($column.name) )// #end                    setterMethod.invoke(right,convert(setterMethod.getParameterTypes()[0],left.${column.getGetMethod()}()));
#if( $ignorefields.contains($column.name) )// #end                    bitOR("$column.getJavaName()",modified);
#if( $ignorefields.contains($column.name) )// #end                }
#end
                methods.get("setNew").invoke(right,left.isNew());
                if( modified.length > 1)
                    methods.get("setModified").invoke(right,modified);
                else
                    methods.get("setModified").invoke(right,modified[0]);
            }catch(RuntimeException e){
                throw e;
            }catch(Exception e){
                throw new RuntimeException(e);
            }
        }}; 
#end

}
