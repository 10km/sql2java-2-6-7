#parse( "schema.include.vm" )
#parse( "header.include.vm" )
#parse( "macros.include.vm" )
#set ( $javaClassName = 'BeanConverterUtils' )
#set( $ignorefields= $codewriter.getProperty('general.beanconverter.tonative.ignore') )
$codewriter.setCurrentJavaFilename($gpkg, "${javaClassName}.java")
package ${gpkg};
import java.io.PrintWriter;
import java.io.StringWriter;
import java.lang.reflect.Method;
import java.nio.ByteBuffer;
import java.util.Map;
import java.util.ArrayList;
import java.util.Hashtable;
import java.util.List;

import ${gpkg}.IBeanConverter;

#foreach ( $table in $tables )
import ${gpkg}.${table.asBeanClassNSP()};
#end

/**
 * generic type converter classes of {@link IBeanConverter} implementation for #join($tables "$e.name" ',')<br>
 * @author guyadong
 *
 */
public class ${javaClassName} implements Constant {
    private static class NullCastPrimitiveException extends ClassCastException {
        private static final long serialVersionUID = 1L;
        NullCastPrimitiveException(String message) {
            super(message);
        }
    }
    private ${javaClassName}(){}
    /**
     * 返回buffer中所有字节(position~limit),不改变buffer状态
     * @param buffer
     * @return
     */
    private static final byte[] getBytesInBuffer(ByteBuffer buffer){
        int pos = buffer.position();
        try{
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            return bytes;
        }finally{
            buffer.position(pos);
        }
    }
    private static final List<Long> toList(long[] array) {
        ArrayList<Long> result = new ArrayList<Long>(array.length);
        for (int i = 0; i < array.length; i++) {
            result.add(new Long(array[i]));
        }
        return result;
    }
    private static final long[] toPrimitive(List<Long> list) {        
        long[] dst = new long[list.size()];
        Long element;
        for (int i = 0; i < dst.length; i++) {
            if(null == (element = list.get(i)))
                throw new IllegalArgumentException("can't cast List<Long> to long[] because of null element");
            dst[i] = element.longValue();
        }
        return dst;
    }
    /**
     * {@code source}转为{@code type}指定的类型
     * @param type destination type
     * @param source  source object
     * @return
     */
    @SuppressWarnings({ "unchecked" })
    private static final <T> T cast(Class<T> type,Object source){
        try{
            if(null ==source && type.isPrimitive())
                throw new NullCastPrimitiveException(String.format("can't convert null to primitive type %s",type.getSimpleName()));
            return (T) source;
        }catch(ClassCastException cce){
            // long[] -> List  
            if(List.class.isAssignableFrom(type) && (source instanceof long[])){
                return (T) toList((long[]) source);
            }
            // List -> long[]   
            if(long[].class == type && (source instanceof List)){
                return (T) toPrimitive( (List<Long>) source);
            }
            // Long -> Date
            if(java.util.Date.class.isAssignableFrom(type) && (source instanceof Long)){
                try {
                    // call constructor,such as  java.util.Date#Date(long), java.sql.Time.Time(long)
                    return type.getConstructor(long.class).newInstance(source);
                } catch (Exception e) {
                    StringWriter writer = new StringWriter();
                    e.printStackTrace(new PrintWriter(writer));
                    throw new ClassCastException(writer.toString());
                }
            }
            // Date -> Long,long
            if( (long.class == type || Long.class == type) && source instanceof java.util.Date){
                    Long time = ((java.util.Date)source).getTime();
                    return (T)time;
            }
            // byte[] -> ByteBuffer
            if(ByteBuffer.class == type && source instanceof byte[]){
                return (T) ByteBuffer.wrap((byte[]) source);
            }
            // ByteBuffer -> byte[]
            if(byte[].class == type && source instanceof ByteBuffer){
                return (T) getBytesInBuffer((ByteBuffer) source);
            }
            throw cce;
        }
    }
    private static final boolean bitCheck(int index,long...bits){
        return 0 != (bits[index>>6]&(1L<<(index&0x3f)));
    }
    private static final long[] bitOR(int index,long... bits){
         bits[index>>6] |= (1L<<(index&0x3f));
         return bits;
    }
#foreach ( $table in $tables )
#set ( $leftClass  = "${table.asBeanClassNSP()}" )
#set ( $rightClass = "R_${table.asCoreClassNSP().toUpperCase()}" )
    /**
     * implementation of {@link IBeanConverter} by reflect<br>
     * generic type converter between {@link $leftClass} and $rightClass <br>
     * @author guyadong
     * @param <$rightClass> right type
     *
     */
    public static class #converterClass(${leftClass})<$rightClass> extends IBeanConverter.AbstractHandle<${leftClass},${rightClass}>{
        private final Map<String,Method> methods = new Hashtable<String,Method>();
        private final Map<String,Integer> rightIndexs = new Hashtable<String,Integer>();
        private final Map<String, Class<?>> setterParams = new Hashtable<String,Class<?>>();

        private boolean bitCheck(String name,long...bits){
            Integer id = rightIndexs.get(name);
            return (null == id)?false:BeanConverterUtils.bitCheck(id.intValue(),bits);
        }
        private long[] bitOR(String name,long... bits){
            return BeanConverterUtils.bitOR(rightIndexs.get(name),bits);
        }
        private void getGetter(String name){
            try{
                methods.put(name,rightType.getMethod(name));
            }catch(NoSuchMethodException e){}
        }
        private void getSetter(String name, Class<?>...types) throws NoSuchMethodException{
            for(Class<?>paramType:types){
                try{
                    methods.put(name,rightType.getMethod(name,paramType));
                    setterParams.put(name, paramType);
                    return;
                }catch(NoSuchMethodException e){
                    continue;
                }
            }
            throw new NoSuchMethodException();
        }
        private void getSetterNoThrow(String name, Class<?>...types){
            try{
                getSetter(name,types);
            }catch(NoSuchMethodException e){}
        }
        /** 
         * usage: <pre>new #converterClass(${leftClass})&lt;Model&gt;(javaFields){};</pre>
         * @param javaFields a comma splice string,including all field name of $rightClass,<br>
         *                   if null or empty, use default string:{@link Constant#$table.name.toUpperCase()_JAVA_FIELDS}
         */
        public #converterClass(${leftClass})(String javaFields){
            super();
            init(javaFields);
        }
        /** @see ${esc.hash}#converterClass(${leftClass})(String) */
        public #converterClass(${leftClass})(){
            this(null);
        }
        /**
         * constructor
         * @param leftClass
         * @param rightClass
         * @param javaFields see also {@link ${esc.hash}#converterClass(${leftClass})(String)}
         */
        public #converterClass(${leftClass}) (Class<${leftClass}> leftClass, Class<$rightClass> rightClass,String javaFields){
            super(leftClass,rightClass);
            init(javaFields);
        }
        /** @see ${esc.hash}#converterClass(${leftClass})(Class,Class,String) */
        public #converterClass(${leftClass}) (Class<${leftClass}> leftClass, Class<$rightClass> rightClass){
            this(leftClass,rightClass,null);
        }
        private void init(String javaFields){
            if(null == javaFields || javaFields.isEmpty()){
                javaFields = $table.name.toUpperCase()_JAVA_FIELDS;
            }
            String []rightFields = javaFields.split(",");
            for(int i = 0 ; i < rightFields.length; ++i){
                String field = rightFields[i].trim();
                if(!field.matches("\\w+"))
                    throw new IllegalArgumentException("invalid 'javaFields':" + javaFields);
                rightIndexs.put(field,i);
            }
            try{
                methods.put("isNew",rightType.getMethod("isNew"));
                methods.put("getModified",rightType.getMethod("getModified"));
                getSetter("setNew",boolean.class);
                if(rightIndexs.size() > 64)
                    getSetter("setModified",long[].class,List.class);
                else
                    getSetter("setModified",long.class);
            }catch(NoSuchMethodException e){
                throw new RuntimeException(e);
            }
            getGetter("getInitialized");
            if(rightIndexs.size() > 64)
                getSetterNoThrow("setInitialized",long[].class,List.class);
            else
                getSetterNoThrow("setInitialized",long.class);

#foreach ( $column in $table.columns ) 
#set ( $methodName = ${column.getSetMethod()}) 
#set ( $javaType = ${column.getJavaType()})
#set ( $javaPrimaryType = ${column.getJavaPrimaryType()})
            getGetter("$methodName");
#if ( $column.hasPrimaryType())
#if($column.isDate())
            getSetterNoThrow("$methodName",${javaType}.class,Long.class,long.class);  
#else
            getSetterNoThrow("$methodName",${javaType}.class,${javaPrimaryType}.class);                    
#end
#elseif($column.isBinary())
            getSetterNoThrow("$methodName",java.nio.ByteBuffer.class,byte[].class);                    
#else
            getSetterNoThrow("$methodName",${javaType}.class); 
#end
#end
        }
        @Override
        protected void _fromRight(${leftClass} left, ${rightClass} right) {
            try{
                Method getterMethod;
                left.resetIsModified();
                long[] modified;
                if(rightIndexs.size() > 64)
                    modified = (long[])methods.get("getModified").invoke(right);
                else
                    modified = new long[]{(long)methods.get("getModified").invoke(right)};
#foreach ( $column in $table.columns )
                if( bitCheck("$column.getJavaName()",modified) && (null != (getterMethod = methods.get("${column.getGetMethod()}"))))
                    left.$column.getSetMethod()(cast(${column.getJavaType()}.class,getterMethod.invoke(right)));
#end
                left.isNew((boolean)methods.get("isNew").invoke(right));
            }catch(RuntimeException e){
                throw e;
            }catch(Exception e){
                throw new RuntimeException(e);
            }
        }

        @Override
        protected void _toRight(${leftClass} left, ${rightClass} right) {
            try{
                Method setterMethod;
                long[] modified = new long[(rightIndexs.size() + 63)>>6];
                for(int i = 0 ;i < modified.length; ++i)modified[i] = 0L;
#foreach ( $column in $table.columns )
#set ( $setterName = ${column.getSetMethod()}) 
#set($isIgnore = $ignorefields.contains($column.name))
#if( $isIgnore )// IGNORE field $column.fullName , controlled by 'general.beanconverter.tonative.ignore' in properties file
/*
#end
               if(null != (setterMethod = methods.get("$setterName")) && left.${column.getInitializedMethod()}()){
                    try{
                        setterMethod.invoke(right,cast(setterParams.get("$setterName"),left.${column.getGetMethod()}()));
                        bitOR("$column.getJavaName()",modified);
                    }catch(NullCastPrimitiveException e){}
                }
#if( $isIgnore )*/
#end
#end
                if(null != (setterMethod = methods.get("setInitialized"))){
                    if( modified.length > 1)
                        setterMethod.invoke(right,cast(setterParams.get("setInitialized"),modified));
                    else
                        setterMethod.invoke(right,modified[0]);
                }
                methods.get("setNew").invoke(right,left.isNew());
                if( modified.length > 1)
                    methods.get("setModified").invoke(right,cast(setterParams.get("setModified"),modified));
                else
                    methods.get("setModified").invoke(right,modified[0]);
            }catch(RuntimeException e){
                throw e;
            }catch(Exception e){
                throw new RuntimeException(e);
            }
        }
    }; 
#end

}
