#parse( "header.include.vm" )
#parse( "schema.include.vm" )
#parse( "table.include.vm" )
######################
#set ( $gpkg = $codewriter.getProperty('general.package') )
#set ( $subpkg=$db.engineAsSubPackage() )
#set ( $managerClassNSP = $table.asManagerClassNSP() )
#set ( $nativeClass = $table.asBeanClass() )
#set ( $beanClass = $table.asBeanClassNSP() )
#set ( $listenerClass = $table.asListenerClassNSP() )
#set ( $nativeListener = $table.asListenerClass() )
$codewriter.setCurrentJavaFilename("${gpkg}.${subpkg}", "${managerClassNSP}.java")
package ${gpkg}.${subpkg};

import java.util.concurrent.Callable;

import ${gpkg}.Constant;
import ${gpkg}.${beanClass};
import ${gpkg}.IBeanConverter;
import ${gpkg}.IDbConverter;
import ${gpkg}.TableManager;
import ${gpkg}.$table.asManagerInterfaceNSP();
#foreach ($linkedTable in $linkedTables)
import ${gpkg}.${linkedTable.asBeanClassNSP()};
#end
import ${gpkg}.TableListener;
import ${gpkg}.WrapDAOException;

import ${pkg}.exception.DAOException;
import ${table.getPackage()}.${managerClass};
import ${table.getPackage()}.${nativeClass};

/**
 * Handles database calls (save, load, count, etc...) for the $tablename table.<br>
 * all {@link DAOException} be wrapped as {@link WrapDAOException} to throw.
#if ( $table.hasRemarks() )
 * Remarks: $table.getRemarks()
#end
 * @author guyadong
 */
public class $managerClassNSP extends TableManager.Adapter<$beanClass> implements $table.asManagerInterfaceNSP()
{
    private $managerClass nativeManager = ${managerClass}.getInstance();
    private IDbConverter<#join($tables "${e.getPackage()}.${e.asBeanClass()}" ',')> dbConverter = DbConverter.INSTANCE;
    private IBeanConverter<$beanClass,${nativeClass}> beanConverter = dbConverter.get${beanClass}Converter();
    private static $managerClassNSP singleton = new $managerClassNSP();

    /**
    * @return table name
    */
    public String getTableName() {
        return this.nativeManager.getTableName();
    }

    /**
    * @return field names of table
    */
    public String getFields() {
        return this.nativeManager.getFields();
    }
    
    public String getFullFields() {
        return this.nativeManager.getFullFields();
    }
    
    /**
    * @return primarykeyNames
    */
    public String[] getPrimarykeyNames() {
        return this.nativeManager.getPrimarykeyNames();
    }
    
    /**
     * Get the {@link $managerClassNSP} singleton.
     *
     * @return {@link $managerClassNSP}
     */
    public static $managerClassNSP getInstance()
    {
        return singleton;
    }
   
    @Override
    protected Class<$beanClass> _beanType(){
        return ${beanClass}.class;
    }
    
    public IDbConverter<#join($tables "${e.getPackage()}.${e.asBeanClass()}" ',')> getDbConverter() {
        return dbConverter;
    }

    /**
     * set  {@link IDbConverter} as converter used by manager.<br>
     * throw {@link NullPointerException} if {@code dbConverter} is null
     * @param dbConverter
     */
    @SuppressWarnings({ "rawtypes", "unchecked" })
    public synchronized void setDbConverter(IDbConverter dbConverter) {
        if( null == dbConverter)
            throw new NullPointerException();
        this.dbConverter = dbConverter;
        this.beanConverter = this.dbConverter.get${beanClass}Converter();
    }
#if ( $table.countPrimaryKeys() > 0 )
    //////////////////////////////////////
    // PRIMARY KEY METHODS
    //////////////////////////////////////

    //1 override $table.asManagerInterfaceNSP()
    @Override 
    public $beanClass loadByPrimaryKey(#join($primaryKeys "$e.getJavaType() $e.getVarName()" ','))
    {
        try{
            return this.beanConverter.fromRight(nativeManager.loadByPrimaryKey(#join($primaryKeys "$e.getVarName()" ',')));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

    //1.2
    @Override
    public $beanClass loadByPrimaryKey(${beanClass} bean)
    {
        try{
            return this.beanConverter.fromRight(this.nativeManager.loadByPrimaryKey(this.beanConverter.toRight(bean)));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

    //1.3
    @Override
    public $beanClass loadByPrimaryKey(Object ...keys){
        if(keys.length != $table.countPrimaryKeys() )
            throw new IllegalArgumentException("argument number mismatch with primary key number");
#foreach ( $pk in $primaryKeys )
#set( $kidx = $velocityCount - 1 )
        if(! (keys[$kidx] instanceof $pk.getJavaType()))
            throw new IllegalArgumentException("invalid type for the No.$velocityCount argument,expected type:$pk.getJavaType()");
#end        
        return loadByPrimaryKey(#foreach($pk in $primaryKeys)#if ( $velocityCount > 1 ),#end#set( $kidx = $velocityCount - 1 )($pk.getJavaType())keys[$kidx]#end);
    }
    
    //1.4 override $table.asManagerInterfaceNSP()
    @Override 
    public boolean existsPrimaryKey(#join($primaryKeys "$e.getJavaType() $e.getVarName()" ','))
    {
        return null!=loadByPrimaryKey(#join($primaryKeys "$e.getVarName()" ',') );
    }
    
    //2 override $table.asManagerInterfaceNSP()
    @Override 
    public int deleteByPrimaryKey(#join($primaryKeys "$e.getJavaType() $e.getVarName()" ','))
    {
        try
        {
            return nativeManager.deleteByPrimaryKey(#join($primaryKeys "$e.getVarName()" ','));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

    //2.1
    @Override
    public int deleteByPrimaryKey(Object ...keys){
        if(keys.length != $table.countPrimaryKeys() )
            throw new IllegalArgumentException("argument number mismatch with primary key number");
#foreach ( $pk in $primaryKeys )
#set( $kidx = $velocityCount - 1 )
        if(! (keys[$kidx] instanceof $pk.getJavaType()))
            throw new IllegalArgumentException("invalid type for the No.$velocityCount argument,expected type:$pk.getJavaType()");
#end        
        return deleteByPrimaryKey(#foreach($pk in $primaryKeys)#if ( $velocityCount > 1 ),#end#set( $kidx = $velocityCount - 1 )($pk.getJavaType())keys[$kidx]#end);
    }

#end ## $table.countPrimaryKeys() > 0
## ======================================================
## xImportedKeys template
## ======================================================

#if ($table.hasImportedKeys())
    //////////////////////////////////////
    // IMPORT KEY GENERIC METHOD
    //////////////////////////////////////
    
    private static final Class<?>[] importedBeanTypes = new Class<?>[]{#foreachImportedTables('native' $table "${m_importedClass}.class" ',' '')};

    /**
     * @see #getImportedBeansAsList($beanClass,int)
     */
    @SuppressWarnings("unchecked")
    @Override
    public <T extends ${gpkg}.BaseBean<?>> T[] getImportedBeans($beanClass bean, int ikIndex){
        return getImportedBeansAsList(bean, ikIndex).toArray((T[])java.lang.reflect.Array.newInstance(importedBeanTypes[ikIndex],0));
    }
    
    /**
     * Retrieves imported T objects by ikIndex.<br>
     * @param <T>
     * <ul>
    #foreachImportedTables('native' $table " *     <li> {@link Constant#${m_importedTable.asIKConst($m_fkName)}} -> {@link ${m_importedClass}}</li>" '    ' 'true')
     * </ul>
     * @param bean the {@link $beanClass} object to use
     * @param ikIndex valid values: #foreachImportedTables('native' $table "{@link Constant#${m_importedTable.asIKConst($m_fkName)}}" ',' '')

     * @return the associated T beans or {@code null} if {@code bean} is {@code null}
     */
    @SuppressWarnings("unchecked")
    @Override
    public <T extends ${gpkg}.BaseBean<?>> java.util.List<T> getImportedBeansAsList($beanClass bean,int ikIndex){
        switch(ikIndex){
#foreach($importedTable in $importedTables)
#set ( $importedClass = "$importedTable.asBeanClass()" )
#set ( $importedClassManager = "$importedTable.asManagerClass()" )
#foreach( $fkName in $importedTable.getFkMapNames($table.name) )
#set ( $columnsOfFk = $importedTable.getForeignKeysByFkName($fkName) )
        case ${importedTable.asIKConst($fkName)}:
            return (java.util.List<T>)this.${importedTable.getImportedBeansGetMethod($fkName)}AsList(bean);
#end
#end
        }
        throw new IllegalArgumentException(String.format("invalid ikIndex %d", ikIndex));
    }
    /**
     * Set the T objects as imported beans of bean object by ikIndex.<br>
     * @param <T>
     * 
     * <ul>
    #foreachImportedTables('native' $table " *     <li> {@link Constant#${m_importedTable.asIKConst($m_fkName)}} -> {@link ${m_importedClass}}</li>" '    ' 'true')
     * </ul>
     * @param bean the {@link $beanClass} object to use
     * @param importedBeans the ${importedClass} array to associate to the {@link $beanClass}
     * @param ikIndex valid values: #foreachImportedTables('native' $table "{@link Constant#${m_importedTable.asIKConst($m_fkName)}}" ',' '')

     * @return importedBeans always
     */
    @SuppressWarnings("unchecked")
    @Override
    public <T extends ${gpkg}.BaseBean<?>> T[] setImportedBeans($beanClass bean,T[] importedBeans,int ikIndex){
        switch(ikIndex){
#foreach($importedTable in $importedTables)
#set ( $importedClass = "$importedTable.asBeanClassNSP()" )
#set ( $importedClassManager = "$importedTable.asManagerClass()" )
#foreach( $fkName in $importedTable.getFkMapNames($table.name) )
#set ( $columnsOfFk = $importedTable.getForeignKeysByFkName($fkName) )
        case ${importedTable.asIKConst($fkName)}:
            return (T[])${importedTable.getImportedBeansSetMethod($fkName)}(bean,(${importedClass}[])importedBeans);
#end
#end
        }
        throw new IllegalArgumentException(String.format("invalid ikIndex %d", ikIndex));
    }
    /**
     * Set the importedBeans associates to the bean by ikIndex<br>
     * @param <T>
     * <ul>
    #foreachImportedTables('native' $table " *     <li> {@link Constant#${m_importedTable.asIKConst($m_fkName)}} -> {@link ${m_importedClass}}</li>" '    ' 'true')
     * </ul>
     * @param bean the {@link $beanClass} object to use
     * @param importedBeans the <T> object to associate to the {@link $beanClass}
     * @param ikIndex valid values: #foreachImportedTables('native' $table "{@link Constant#${m_importedTable.asIKConst($m_fkName)}}" ',' '')

     * @return importedBeans always
     */
    @SuppressWarnings("unchecked")
    @Override
    public <T extends ${gpkg}.BaseBean<?>,C extends java.util.Collection<T>> C setImportedBeans($beanClass bean,C importedBeans,int ikIndex){
        switch(ikIndex){
#foreach($importedTable in $importedTables)
#set ( $importedClass = "$importedTable.asBeanClassNSP()" )
#set ( $importedClassManager = "$importedTable.asManagerClass()" )
#foreach( $fkName in $importedTable.getFkMapNames($table.name) )
#set ( $columnsOfFk = $importedTable.getForeignKeysByFkName($fkName) )
        case ${importedTable.asIKConst($fkName)}:
            return (C)${importedTable.getImportedBeansSetMethod($fkName)}(bean,(java.util.Collection<${importedClass}>)importedBeans);
#end
#end
        }
        throw new IllegalArgumentException(String.format("invalid ikIndex %d", ikIndex));
    }
#end ## $table.hasImportedKeys()

#foreach ($importedTable in $importedTables)
#if ( $velocityCount == 1 )

    //////////////////////////////////////
    // GET/SET IMPORTED KEY BEAN METHOD
    //////////////////////////////////////
#end
#set ( $importedClass = "$importedTable.asBeanClassNSP()" )
#set ( $importedNative = "$importedTable.asBeanClass()" )
#set ( $importedClassManager = "$importedTable.asManagerClassNSP()" )
#foreach( $fkName in $importedTable.getFkMapNames($table.name) )
#set ( $columnsOfFk = $importedTable.getForeignKeysByFkName($fkName) )
    //3.1 GET IMPORTED override $table.asManagerInterfaceNSP()
    @Override 
    public $importedClass[] ${importedTable.getImportedBeansGetMethod($fkName)}($beanClass bean)
    {
        return this.${importedTable.getImportedBeansGetMethod($fkName)}AsList(bean).toArray(new $importedClass[0]);
    }
    //3.1.2 GET IMPORTED override $table.asManagerInterfaceNSP()
    @Override
    public $importedClass[] ${importedTable.getImportedBeansGetMethod($fkName)}(#join($primaryKeys "$e.getJavaType() $e.getFullVarName()" ','))
    {
        ${beanClass} bean = new ${beanClass}();
#foreach ( $pk in $primaryKeys )
        bean.${pk.getSetMethod()}(${pk.getFullVarName()});
#end       
        return ${importedTable.getImportedBeansGetMethod($fkName)}(bean);
    }
    //3.2 GET IMPORTED override $table.asManagerInterfaceNSP()
    @Override 
    public java.util.List<$importedClass> ${importedTable.getImportedBeansGetMethod($fkName)}AsList($beanClass bean)
    {
        try {
            return this.dbConverter.get${importedClass}Converter().fromRight(nativeManager.${importedTable.getImportedBeansGetMethod($fkName)}AsList( this.beanConverter.toRight(bean)));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }
    //3.2.2 GET IMPORTED override $table.asManagerInterfaceNSP()
    @Override
    public java.util.List<$importedClass> ${importedTable.getImportedBeansGetMethod($fkName)}AsList(#join($primaryKeys "$e.getJavaType() $e.getFullVarName()" ','))
    {
         ${beanClass} bean = new ${beanClass}();
#foreach ( $pk in $primaryKeys )
        bean.${pk.getSetMethod()}(${pk.getFullVarName()});
#end       
        return ${importedTable.getImportedBeansGetMethod($fkName)}AsList(bean);
    }
    //3.3 SET IMPORTED override $table.asManagerInterfaceNSP()
    @Override 
    public $importedClass[] ${importedTable.getImportedBeansSetMethod($fkName)}($beanClass bean , $importedClass[] importedBeans)
    {
        if(null != importedBeans){
            for( $importedClass importBean : importedBeans ){
                ${importedClassManager}.getInstance().$importedTable.getReferencedVarSetMethod($fkName)(importBean , bean);
            }
        }
        return importedBeans;
    }

    //3.4 SET IMPORTED override $table.asManagerInterfaceNSP()
    @Override 
    public <C extends java.util.Collection<$importedClass>> C ${importedTable.getImportedBeansSetMethod($fkName)}($beanClass bean , C importedBeans)
    {
        if(null != importedBeans){
            for( $importedClass importBean : importedBeans ){
                ${importedClassManager}.getInstance().$importedTable.getReferencedVarSetMethod($fkName)(importBean , bean);
            }
        }
        return importedBeans;
    }
#end
#end


## ======================================================
## only xImportedKeys template
## ======================================================
#if( $table.hasForeignTables() || $table.hasImportedTables() )
    //3.5 SYNC SAVE override $table.asManagerInterfaceNSP()
    @Override  
    public $beanClass save($beanClass bean
        #foreachForeignTables('native' $table  ", $m_foreignClass $table.asRefArg($m_fkName) " '' '')

        #foreachImportedTables('native' $table  ", $m_importedClass[] $m_importedTable.asImpArg($m_fkName) " '' ''))
    {
        try{
            return this.beanConverter.fromRight(bean,nativeManager.save(this.beanConverter.toRight(bean)
                #foreachForeignTables('native' $table  ", this.dbConverter.get${m_foreignClass}Converter().toRight($table.asRefArg($m_fkName)) " '' '')
                #foreachImportedTables('native' $table  ", this.dbConverter.get${m_importedClass}Converter().toRight($m_importedTable.asImpArg($m_fkName))  " '' '')));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    } 

    //3.6 SYNC SAVE AS TRANSACTION override $table.asManagerInterfaceNSP()
    @Override 
    public $beanClass saveAsTransaction(final $beanClass bean
        #foreachForeignTables('native' $table  ",final $m_foreignClass $table.asRefArg($m_fkName) " '' '')

        #foreachImportedTables('native' $table  ",final $m_importedClass[] $m_importedTable.asImpArg($m_fkName) " '' ''))
    {
        return this.runAsTransaction(new Callable<$beanClass>(){
            @Override
            public $beanClass call() throws Exception {
                return save(bean #foreachForeignTables('native' $table  ", $table.asRefArg($m_fkName) " '' '')#foreachImportedTables('native' $table  ", $m_importedTable.asImpArg($m_fkName) " '' ''));
            }});
    }
#if( $table.hasImportedTables() )
    //3.7 SYNC SAVE override $table.asManagerInterfaceNSP()
    @Override 
    public $beanClass save($beanClass bean
        #foreachForeignTables('native' $table  ", $m_foreignClass $table.asRefArg($m_fkName) " '' '')

        #foreachImportedTables('native' $table  ", java.util.Collection<$m_importedClass> $m_importedTable.asImpArg($m_fkName) " '' ''))
    {
        try{
            return this.beanConverter.fromRight(bean,nativeManager.save(this.beanConverter.toRight(bean)
                #foreachForeignTables('native' $table  ", this.dbConverter.get${m_foreignClass}Converter().toRight($table.asRefArg($m_fkName)) " '' '')
                #foreachImportedTables('native' $table  ", this.dbConverter.get${m_importedClass}Converter().toRight($m_importedTable.asImpArg($m_fkName))  " '' '')));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }   

    //3.8 SYNC SAVE AS TRANSACTION override $table.asManagerInterfaceNSP()
    @Override 
    public $beanClass saveAsTransaction(final $beanClass bean
        #foreachForeignTables('native' $table  ",final $m_foreignClass $table.asRefArg($m_fkName) " '' '')

        #foreachImportedTables('native' $table  ",final  java.util.Collection<$m_importedClass> $m_importedTable.asImpArg($m_fkName) " '' ''))
    {
        return this.runAsTransaction(new Callable<$beanClass>(){
            @Override
            public $beanClass call() throws Exception {
                return save(bean #foreachForeignTables('native' $table  ", $table.asRefArg($m_fkName) " '' '')#foreachImportedTables('native' $table  ", $m_importedTable.asImpArg($m_fkName) " '' ''));
            }});
    }
#end ## $table.hasImportedTables()
    /**
     * Save the {@link $beanClass} bean and referenced beans and imported beans into the database.
     *
     * @param bean the {@link $beanClass} bean to be saved
     * @param args referenced beans or imported beans<br>
     *      see also {@link #save($beanClass #foreachForeignTables('native' $table  ", $m_foreignClass " '' '')#foreachImportedTables('native' $table  ", $m_importedClass[] " '' ''))}
     * @return the inserted or updated {@link $beanClass} bean
     */
    //3.9 SYNC SAVE 
    @Override
    public $beanClass save($beanClass bean,Object ...args) 
    {
#set ( $argLength = $table.countForeignKeyNames() + $table.countImportedKeyNames() )
#set ( $argIndex = 0 )
#set ( $argCount = 1 )
#set ( $callList= "" )
        if(args.length > $argLength)
            throw new IllegalArgumentException("too many dynamic arguments,max dynamic arguments number: $argLength");
#foreach($foreignTable in $foreignTables)
#set ( $foreignClass = "$foreignTable.asBeanClassNSP()" )
#set ( $foreignClassManager = "$foreignTable.asManagerClass()" )
#foreach ( $fkName in $table.getFkMapNames($foreignTable.name) )
#set ( $columnsOfFk = $table.getForeignKeysByFkName($fkName) )
        if( args.length > $argIndex && null != args[$argIndex] && !(args[$argIndex] instanceof $foreignClass)){
            throw new IllegalArgumentException("invalid type for the No.$argCount dynamic argument,expected type:$foreignClass");
        }
#set ( $callList = "$callList,(args.length < $argCount || null == args[$argIndex])?null:($foreignClass)args[$argIndex]")
#set ( $argIndex = $argIndex + 1 )            
#set ( $argCount = $argCount + 1 )
#end
#end
#foreach($importedTable in $importedTables)
#set ( $importedClass = "$importedTable.asBeanClassNSP()" )
#set ( $importedClassManager = "$importedTable.asManagerClass()" )
#foreach ( $fkName in $importedTable.getFkMapNames($table.name) )
#set ( $columnsOfFk = $importedTable.getForeignKeysByFkName($fkName) )
#set ( $impVar= $importedTable.asImpArg($fkName) )
        if( args.length > $argIndex && null != args[$argIndex] && !(args[$argIndex] instanceof $importedClass[])){
            throw new IllegalArgumentException("invalid type for the No.$argCount argument,expected type:$importedClass[]");
        }
#set ( $callList = "$callList,(args.length < $argCount || null == args[$argIndex])?null:($importedClass[])args[$argIndex]")
#set ( $argIndex = $argIndex + 1 )            
#set ( $argCount = $argCount + 1 )
#end
#end
        return save(bean$callList);
    } 

    /**
     * Save the {@link $beanClass} bean and referenced beans and imported beans into the database.
     *
     * @param bean the {@link $beanClass} bean to be saved
     * @param args referenced beans or imported beans<br>
     *      see also {@link #save($beanClass #foreachForeignTables('native' $table  ", $m_foreignClass " '' '')#foreachImportedTables('native' $table  ", java.util.Collection " '' ''))}
     * @return the inserted or updated {@link $beanClass} bean
     */
    //3.10 SYNC SAVE 
    @SuppressWarnings("unchecked")
    @Override
    public $beanClass saveCollection($beanClass bean,Object ...inputs)
    {
#set ( $argLength = $table.countForeignKeyNames() + $table.countImportedKeyNames() )
#set ( $argIndex = 0 )
#set ( $argCount = 1 )
#set ( $callList= "" )
        if(inputs.length > $argLength)
            throw new IllegalArgumentException("too many dynamic arguments,max dynamic arguments number: $argLength");
        Object[] args = new Object[$argLength];
        System.arraycopy(inputs,0,args,0,$argLength);
#foreach($foreignTable in $foreignTables)
#set ( $foreignClass = "$foreignTable.asBeanClassNSP()" )
#foreach ( $fkName in $table.getFkMapNames($foreignTable.name) )
#set ( $columnsOfFk = $table.getForeignKeysByFkName($fkName) )
        if( args.length > $argIndex && null != args[$argIndex] && !(args[$argIndex] instanceof $foreignClass)){
            throw new IllegalArgumentException("invalid type for the No.$argCount dynamic argument,expected type:$foreignClass");
        }
#set ( $callList = "$callList,null == args[$argIndex]?null:($foreignClass)args[$argIndex]")
#set ( $argIndex = $argIndex + 1 )            
#set ( $argCount = $argCount + 1 )
#end
#end
#foreach($importedTable in $importedTables)
#set ( $importedClass = "$importedTable.asBeanClassNSP()" )
#foreach ( $fkName in $importedTable.getFkMapNames($table.name) )
#set ( $columnsOfFk = $importedTable.getForeignKeysByFkName($fkName) )
#set ( $impVar= $importedTable.asImpArg($fkName) )
        if( args.length > $argIndex && null != args[$argIndex] && !(args[$argIndex] instanceof java.util.Collection)){
            throw new IllegalArgumentException("invalid type for the No.$argCount argument,expected type:java.util.Collection<$importedClass>");
        }
#set ( $callList = "$callList,null == args[$argIndex]?null:(java.util.Collection<$importedClass>)args[$argIndex]")
#set ( $argIndex = $argIndex + 1 )            
#set ( $argCount = $argCount + 1 )
#end
#end
        return save(bean$callList);
    }

#end ## $table.hasForeignTables() || $table.hasImportedTables()
## ======================================================
## xForeignKeys template
## ======================================================
#if ($table.hasForeignKeys())
    //////////////////////////////////////
    // FOREIGN KEY GENERIC METHOD
    //////////////////////////////////////

    /**
     * Retrieves the bean object referenced by fkIndex.<br>
     * @param <T>
     * <ul>
    #foreachForeignTables('native' $table " *     <li> {@link Constant#${table.asFKConst($m_fkName)}} -> {@link ${m_foreignClass}}</li>" '    ' 'true')
     * </ul>
     * @param bean the {@link $beanClass} object to use
     * @param fkIndex valid values: <br>
     *        #foreachForeignTables('native' $table "{@link Constant#${table.asFKConst($m_fkName)}}" ',' '')

     * @return the associated <T> bean or {@code null} if {@code bean} or {@code beanToSet} is {@code null}
     */
    @SuppressWarnings("unchecked")
    @Override
    public <T extends ${gpkg}.BaseBean<?>> T getReferencedBean($beanClass bean,int fkIndex){
        switch(fkIndex){
#foreach($foreignTable in $foreignTables)
#set ( $foreignClass = "$foreignTable.asBeanClass()" )
#set ( $foreignClassManager = "$foreignTable.asManagerClass()" )
#foreach( $fkName in $table.getFkMapNames($foreignTable.name) )
#set ( $columnsOfFk = $table.getForeignKeysByFkName($fkName) )
        case ${table.asFKConst($fkName)}:
            return  (T)this.${table.getReferencedVarGetMethod($fkName)}(bean);
#end
#end
        }
        throw new IllegalArgumentException(String.format("invalid fkIndex %d", fkIndex));
    }
    /**
     * Associates the {@link $beanClass} object to the bean object by fkIndex field.<br>
     * 
     * @param <T> see also {@link #getReferencedBean($beanClass,int)}
     * @param bean the {@link $beanClass} object to use
     * @param beanToSet the <T> object to associate to the {@link $beanClass}
     * @param fkIndex valid values: see also {@link #getReferencedBean($beanClass,int)}
     * @return always beanToSet saved
     */
    @SuppressWarnings("unchecked")
    @Override
    public <T extends ${gpkg}.BaseBean<?>> T setReferencedBean($beanClass bean,T beanToSet,int fkIndex){
        switch(fkIndex){
#foreach($foreignTable in $foreignTables)
#set ( $foreignClass = "$foreignTable.asBeanClassNSP()" )
#set ( $foreignClassManager = "$foreignTable.asManagerClass()" )
#foreach( $fkName in $table.getFkMapNames($foreignTable.name) )
#set ( $columnsOfFk = $table.getForeignKeysByFkName($fkName) )
        case ${table.asFKConst($fkName)}:
            return  (T)this.${table.getReferencedVarSetMethod($fkName)}(bean, (${foreignClass})beanToSet);
#end
#end
        }
        throw new IllegalArgumentException(String.format("invalid fkIndex %d", fkIndex));
    }
#end## $table.hasForeignKeys()
    
#foreach ($foreignTable in $foreignTables)
#if ( $velocityCount == 1 )
    //////////////////////////////////////
    // GET/SET FOREIGN KEY BEAN METHOD
    //////////////////////////////////////

#end
#set ( $foreignClass = "$foreignTable.asBeanClassNSP()" )
#set ( $foreignNative = "$foreignTable.asBeanClass()" )
#set ( $foreignClassManager = "$foreignTable.asManagerClass()" )
#foreach( $fkName in $table.getFkMapNames($foreignTable.name) )
#set ( $columnsOfFk = $table.getForeignKeysByFkName($fkName) )

    //5.1 GET REFERENCED VALUE override $table.asManagerInterfaceNSP()
    @Override 
    public $foreignClass $table.getReferencedVarGetMethod($fkName)($beanClass bean)
    {
        try{
            return this.dbConverter.get${foreignClass}Converter().fromRight(this.nativeManager.$table.getReferencedVarGetMethod($fkName)(this.beanConverter.toRight(bean)));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
        
    }

    //5.2 SET REFERENCED override $table.asManagerInterfaceNSP()
    @Override 
    public $foreignClass $table.getReferencedVarSetMethod($fkName)($beanClass bean, $foreignClass beanToSet)
    {
        try{
            return this.dbConverter.get${foreignClass}Converter().fromRight(beanToSet,this.nativeManager.$table.getReferencedVarSetMethod($fkName)(this.beanConverter.toRight(bean),this.dbConverter.get${foreignClass}Converter().toRight(beanToSet)));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }
#end
#end

    //////////////////////////////////////
    // SQL 'WHERE' METHOD
    //////////////////////////////////////

    //11
    @Override
    public int deleteByWhere(String where)
    {
        try{
            return this.nativeManager.deleteByWhere(where);
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

    //_____________________________________________________________________
    //
    // SAVE
    //_____________________________________________________________________

    //13
    @Override
    protected $beanClass insert($beanClass bean)
    {
        try{
            return this.beanConverter.fromRight(bean,this.nativeManager.insert(this.beanConverter.toRight(bean)));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

    //14
    @Override
    protected $beanClass update($beanClass bean)
    {
        try{
            return this.beanConverter.fromRight(bean,this.nativeManager.update(this.beanConverter.toRight(bean)));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

    //_____________________________________________________________________
    //
    // USING TEMPLATE
    //_____________________________________________________________________
    //18
    @Override
    public $beanClass loadUniqueUsingTemplate(${beanClass} bean)
    {
        try{
            return this.beanConverter.fromRight(this.nativeManager.loadUniqueUsingTemplate(this.beanConverter.toRight(bean)));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
     }

    //20-5
    @Override
    public int loadUsingTemplate(${beanClass} bean, int[] fieldList, int startRow, int numRows,int searchType, Action<$beanClass> action)
    {
        try {
            return this.nativeManager.loadUsingTemplate(this.beanConverter.toRight(bean),fieldList,startRow,numRows,searchType,this.toNative(action));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

    //21
    @Override
    public int deleteUsingTemplate(${beanClass} bean)
    {
        try{
            return this.nativeManager.deleteUsingTemplate(this.beanConverter.toRight(bean));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

#if ($table.countIndices() > 0)

    //_____________________________________________________________________
    //
    // USING INDICES
    //_____________________________________________________________________

#foreach ( $index in $table.getIndices() )
#if($index.isUnique())
    // override $table.asManagerInterfaceNSP()
    @Override 
    public $beanClass loadBy${index.asCamelCaseName()}(#join( $index.getIndexColumnsList() "$e.getJavaType() ${e.getVarName()}" ','))
    {
        try{
            return this.beanConverter.fromRight(this.nativeManager.loadBy${index.asCamelCaseName()}(#join( $index.getIndexColumnsList() "${e.getVarName()}" ',')));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

#else ## $index.isUnique()
    // override $table.asManagerInterfaceNSP()
    @Override 
    public $beanClass[] loadBy${index.asCamelCaseName()}(#join( $index.getIndexColumnsList() "$e.getJavaType() ${e.getVarName()}" ','))
    {
        return this.loadBy${index.asCamelCaseName()}AsList(#join( $index.getIndexColumnsList() "${e.getVarName()}" ',')).toArray(new $beanClass[0]);
    }
    
    // override $table.asManagerInterfaceNSP()
    @Override 
    public java.util.List<$beanClass> loadBy${index.asCamelCaseName()}AsList(#join( $index.getIndexColumnsList() "$e.getJavaType() ${e.getVarName()}" ','))
    {
        try{
            return this.beanConverter.fromRight(this.nativeManager.loadBy${index.asCamelCaseName()}AsList(#join( $index.getIndexColumnsList() "${e.getVarName()}" ',')));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }
#end## $index.isUnique()

    // override $table.asManagerInterfaceNSP()
    @Override 
    public int deleteBy${index.asCamelCaseName()}(#join( $index.getIndexColumnsList() "$e.getJavaType() ${e.getVarName()}" ','))
    {
        try{
            return this.nativeManager.deleteBy${index.asCamelCaseName()}(#join( $index.getIndexColumnsList() "${e.getVarName()}" ','));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }
    
#end
    
    /**
     * Retrieves a list of $beanClass using the index specified by keyIndex.
     * @param keyIndex valid values: <br>
     *        #join($table.getIndices() "{@link Constant#${e.asConstName()}}" ',')

     * @param keys key values of index
     * @return a list of $beanClass
     */
    @Override
    public java.util.List<$beanClass> loadByIndexAsList(int keyIndex,Object ...keys)
    {
        try{
            return this.beanConverter.fromRight(this.nativeManager.loadByIndexAsList(keyIndex,keys));
        }catch(DAOException e){
            throw new WrapDAOException(e);
        }
    }
    
    /**
     * Deletes rows using key.
     * @param keyIndex valid values: <br>
     *        #join($table.getIndices() "{@link Constant#${e.asConstName()}}" ',')

     * @param keys key values of index
     * @return the number of deleted objects
     */
    @Override
    public int deleteByIndex(int keyIndex,Object ...keys)
    {
        try{
            return this.nativeManager.deleteByIndex(keyIndex,keys);
        }catch(DAOException e){
            throw new WrapDAOException(e);
        }
    }
#end##($table.countIndices() > 0)

## Many to Many needs to be templatized.
#set ( $rTables = $codewriter.getRelationTables() )
#foreach ( $rTable in $rTables )
#### if there is a foreign key present in that relation table
#* *##if (! ("$!rTable.getForeignKeyFor( $table )" == "") )
#* *##set ( $oVelocityCount = $velocityCount )
#* *##set ( $lTables = $rTable.linkedTables($db, $codewriter.getTable() ) )
#* *##set ( $rName = $rTable.getName() )
#* *##foreach ( $lTable in $lTables )
#*      *##set ( $lName = $lTable.getName() )
#*      *##if ( $velocityCount == 1 && $oVelocityCount == 1 )
    
    //_____________________________________________________________________
    //
    // MANY TO MANY: LOAD OTHER BEAN VIA JUNCTION TABLE
    //_____________________________________________________________________
#*      *##end
#set ( $strLinkedCore = "$!{codewriter.getClassPrefix()}$lTable.asCoreClass()" )
#set ( $strLinkedBean = "${lTable.asBeanClassNSP()}" )
#set ( $strLinkedNative = "${lTable.asBeanClass()}" )
#set ( $strLinkedManager = "${lTable.asManagerClass()}" )
#set ( $strRelationCore = "${rTable.asCoreClass()}" )
#set ( $strRelationBean = "${rTable.asBeanClass()}" )
#set ( $localKey = $rTable.getForeignKeyFor( $table ) )
#set ( $externalKey = $rTable.getForeignKeyFor( $lTable ) )
    /**
     * Retrieves an array of $strLinkedBean using the relation table $strRelationCore given a $beanClass object.
     *
     * @param bean the $beanClass bean to be used
     * @return an array of $strLinkedBean
     */
    //22 MANY TO MANY
    public $strLinkedBean[] load${strLinkedCore}Via$strRelationCore($beanClass bean) 
    {
         return this.load${strLinkedCore}Via$strRelationCore(this.beanConverter.toRight(bean), 1, -1);
    }

    /**
     * Retrieves an array of $strLinkedBean using the relation table $strRelationCore given a $beanClass object, specifying the start row and the number of rows.
     *
     * @param bean the $beanClass bean to be used
     * @param startRow the start row to be used (first row = 1, last row = -1)
     * @param numRows the number of rows to be retrieved (all rows = a negative number)
     * @return an array of $strLinkedBean
     */
    //23 MANY TO MANY
    public $strLinkedBean[] load${strLinkedCore}Via$strRelationCore($beanClass bean, int startRow, int numRows)
    {
        try
        {
            return this.dbConverter.get${$strLinkedBean}Converter.fromRight(this.nativeManager.load${strLinkedCore}Via$strRelationCore(this.beanConverter.toRight(bean), 1, -1));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }

    }
#* *##end
#* *##end
#end
    //_____________________________________________________________________
    //
    // COUNT
    //_____________________________________________________________________
    //25
    @Override
    public int countWhere(String where)
    {
        try{
            return this.nativeManager.countWhere(where);
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }

    //20
    @Override
    public int countUsingTemplate(${beanClass} bean, int searchType)
    {
        try{
            return this.nativeManager.countUsingTemplate(this.beanConverter.toRight(bean),searchType);
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }


    //_____________________________________________________________________
    //
    // LISTENER
    //_____________________________________________________________________

    //35
    @Override
    public void registerListener(TableListener<$beanClass> listener)
    {
        this.nativeManager.registerListener(this.toNative(listener));
    }

    //36
    @Override
    public void unregisterListener(TableListener<$beanClass> listener)
    {
        this.nativeManager.unregisterListener(this.toNative(listener));
    }
    
    private ${pkg}.TableListener<$nativeClass> toNative(final TableListener<$beanClass> listener) {
        return null == listener ?null:new ${pkg}.TableListener<$nativeClass> (){

            @Override
            public void beforeInsert($nativeClass bean) throws DAOException {
                listener.beforeInsert(${managerClassNSP}.this.beanConverter.fromRight(bean));                
            }

            @Override
            public void afterInsert($nativeClass bean) throws DAOException {
                listener.afterInsert(${managerClassNSP}.this.beanConverter.fromRight(bean));
                
            }

            @Override
            public void beforeUpdate($nativeClass bean) throws DAOException {
                listener.beforeUpdate(${managerClassNSP}.this.beanConverter.fromRight(bean));
                
            }

            @Override
            public void afterUpdate($nativeClass bean) throws DAOException {
                listener.afterUpdate(${managerClassNSP}.this.beanConverter.fromRight(bean));
            }

            @Override
            public void beforeDelete($nativeClass bean) throws DAOException {
                listener.beforeDelete(${managerClassNSP}.this.beanConverter.fromRight(bean));
            }

            @Override
            public void afterDelete($nativeClass bean) throws DAOException {
                listener.afterDelete(${managerClassNSP}.this.beanConverter.fromRight(bean));
            }};
    }

    //_____________________________________________________________________
    //
    // UTILS
    //_____________________________________________________________________

    //43
    @Override
    public boolean isPrimaryKey(String column){
        return this.nativeManager.isPrimaryKey(column);
    }
    
    @Override
    public int loadBySqlForAction(String sql, Object[] argList, int[] fieldList,int startRow, int numRows,Action<$beanClass> action){
        try{
            return this.nativeManager.loadBySqlForAction(sql,argList,fieldList,startRow,numRows,this.toNative(action));
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }
    
    @Override
    public <T>T runAsTransaction(Callable<T> fun) {
        try{
            return this.nativeManager.runAsTransaction(fun);
        }
        catch(DAOException e)
        {
            throw new WrapDAOException(e);
        }
    }
    
    private ${pkg}.TableManager.Action<$nativeClass> toNative(final Action<$beanClass> action){
        if(null == action)
            throw new NullPointerException();
        return new ${pkg}.TableManager.Action<$nativeClass>(){

            @Override
            public void call($nativeClass bean) {
                action.call(${managerClassNSP}.this.beanConverter.fromRight(bean));
            }

            @Override
            public $nativeClass getBean() {
                return  ${managerClassNSP}.this.beanConverter.toRight(action.getBean());
            }};
    }
}
