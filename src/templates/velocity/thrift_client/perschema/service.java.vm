#parse( "header.include.vm" )
#parse( "schema.include.vm" )
#if(!$codewriter.existsDependencyPackage() || !$codewriter.existsDependencySrc())
$codewriter.setSaveCurrentFile(false);
#stop
#end
#set ($swiftParser = $codewriter.loadExtensionClass("gu.rpc.thrift.SwiftServiceParser").newInstance())
#set ($typeUtils = $codewriter.loadExtensionClass("gu.rpc.thrift.TypeUtils").newInstance())
$typeUtils.setPackagePrefix("net.gdface.facelog.db")
$typeUtils.setConvertVarPrefix("ThriftConverter.converter")
$typeUtils.setToBytesMethodPrefix("toBytes")
#set ($classpath = $codewriter.getPropertyExploded("swift.service.classpath"))
#set ($metadata = $swiftParser.parse('net.gdface.facelog.FaceLogDefinition',$classpath))

/*
$metadata.class.name
$swiftParser.output($metadata)
*/
#set ( $thriftSrc = $codewriter.getProperty("dependency.src"))
#set ( $thriftPackage = $codewriter.getProperty("dependency.package"))
#set ( $serviceName = ${metadata.name} )
#set ( $javaClassName = "${serviceName}Client" )
$codewriter.setCurrentJavaFilename("${gpkg}", "${javaClassName}.java")
package ${gpkg};
#macro( convertVar $c)converter$c#end
import com.facebook.nifty.client.FramedClientConnector;
import com.facebook.swift.service.ThriftClientManager;
import static com.google.common.net.HostAndPort.fromParts;

import java.nio.ByteBuffer;
import java.util.*;
import java.util.Map.Entry;

public class $javaClassName implements Constant{
    private final ThriftClientManager clientManager = new ThriftClientManager();
    private final ${thriftPackage}.$serviceName service;
    public $javaClassName(String host,int port){
        try{
            service = clientManager.createClient(
                    new FramedClientConnector(fromParts(host, port)),
                    ${thriftPackage}.${serviceName}.class).get();
            } catch (Exception e) {
                throw new RuntimeException(e);
            }
    }
    public static final byte[] toBytes(ByteBuffer buffer){
        if(null == buffer)return null;
        int pos = buffer.position();
        try{
            byte[] bytes = new byte[buffer.remaining()];
            buffer.get(bytes);
            return bytes;
        }finally{
            buffer.position(pos);
        }
    }
    protected static final<V>Map<byte[],V> toBytesKey(java.util.Map<ByteBuffer,V> source){
        if(null == source)return null;
        HashMap<byte[], V> dest = new java.util.HashMap<byte[],V>();
        for(Entry<ByteBuffer, V> entry:source.entrySet()){
            dest.put(toBytes(entry.getKey()), entry.getValue());
        }
        return dest;
    }
    protected static final<K> java.util.Map<K,byte[]> toBytesValue(java.util.Map<K,ByteBuffer> source){
        if(null == source)return null;
        HashMap<K,byte[]> dest = new java.util.HashMap<K,byte[]>();
        for(Entry<K, ByteBuffer> entry:source.entrySet()){
            dest.put(entry.getKey(),toBytes(entry.getValue()));
        }
        return dest;        
    }
#foreach($method in $sorter.sort($metadata.methods.values(),"name"))
#set ($returnType = $method.returnType.javaType)
#if(!$typeUtils.isVoid($returnType))
#set ( $thriftReturn = "return ")
#else
#set ( $thriftReturn = $null)
#end

    public $typeUtils.swiftType($returnType) ${method.method.name}(#join($method.parameters '$typeUtils.swiftType($e.thriftType.javaType) $e.name' ',')){
#define( $callThrift )service.${method.name}(#join($method.parameters '$typeUtils.toRight(${e.thriftType.javaType}, $e.name)' ',
                '))#end
#if($typeUtils.isTypeOfDao($returnType))
        $!{thriftReturn}$typeUtils.fromRight($returnType,"$callThrift");
#else
        $!{thriftReturn}$callThrift;
#end
    }
#end
}
