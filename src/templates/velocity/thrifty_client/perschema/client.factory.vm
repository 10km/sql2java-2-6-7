#parse( "header.include.vm" )
#parse( "schema.include.vm" )
#set ($swiftParser = $codewriter.loadExtensionClass("gu.rpc.thrift.SwiftServiceParser").newInstance())
#set ($classpath = $codewriter.getPropertyExploded("swift.service.classpath"))
#set ($serviceClassName = $codewriter.getProperty("swift.service.classname"))
#set ($metadata = $swiftParser.parse($serviceClassName,$classpath))
#set ( $thriftPackage = $codewriter.getProperty("dependency.package"))
#set ( $serviceName = ${metadata.name} )
#set ( $javaClassName = "ClientFactory" )
$codewriter.setCurrentJavaFilename("${gpkg}", "${javaClassName}.java")
#macro(clientClass $isAsync)${serviceName}Client#if($isAsync)Async#end#end
#set ( $interfaceClass = "${thriftPackage}.${serviceName}" )
#set ( $thriftyClientClass = "${thriftPackage}.${serviceName}Client" )
package ${gpkg};

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.logging.Logger;

import org.apache.commons.pool2.PooledObject;
import org.apache.commons.pool2.PooledObjectFactory;
import org.apache.commons.pool2.impl.DefaultPooledObject;
import org.apache.commons.pool2.impl.GenericObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;

import com.google.common.base.Throwables;
import com.google.common.cache.Cache;
import com.google.common.cache.CacheBuilder;
import com.google.common.net.HostAndPort;
import com.google.common.util.concurrent.ListenableFuture;

import static com.google.common.net.HostAndPort.fromParts;
import static com.google.common.net.HostAndPort.fromString;
import static com.google.common.base.Preconditions.*;
import com.microsoft.thrifty.protocol.BinaryProtocol;
import com.microsoft.thrifty.protocol.Protocol;
import com.microsoft.thrifty.service.AsyncClientBase;
import com.microsoft.thrifty.transport.SocketTransport;

/**
 * Factory class for creating client instance of IFaceLog<br>
 * Example:<br>
 * <pre>
 * // get a asynchronous instance
 * #clientClass(true) client = ClientFactory.builder()
 * .setHostAndPort("127.0.0.1",9090)
 * .setTimeout(10,TimeUnit.SECONDS)
 * .build();
 * </pre>
 * @author guyadong
 *
 */
public class ClientFactory {
    private static final Logger logger = Logger.getLogger(ClientFactory.class.getSimpleName());
    
    private static final Cache<Class<?>, Object> CLIENT_CACHE = CacheBuilder.newBuilder().softValues().build();
    private static final AsyncClientBase.Listener DEFAULT_LISTENER = new AsyncClientBase.Listener(){
        @Override
        public void onTransportClosed() {}
        @Override
        public void onError(Throwable error) {}
    };
    private volatile GenericObjectPoolConfig channelPoolConfig = new GenericObjectPoolConfig();
    private volatile GenericObjectPool<${thriftyClientClass}> channelPool;
    private HostAndPort hostAndPort;
    private long readTimeout;
    private long connectTimeout;
    private AsyncClientBase.Listener listener = DEFAULT_LISTENER;
    protected ClientFactory() {
    }

    /**
     * set all timeout arguments
     * @param time
     * @param unit
     * @return
     * @see ${esc.hash}setConnectTimeout(long time,TimeUnit unit)
     * @see ${esc.hash}setReadTimeout(long time,TimeUnit unit)
     */
    public ClientFactory setTimeout(long time,TimeUnit unit){
        setConnectTimeout(time,unit);
        setReadTimeout(time,unit);
        return this;
    }
    public ClientFactory setConnectTimeout(long connectTimeout,TimeUnit unit) {
        this.connectTimeout = unit.toMillis(connectTimeout);
        return this;
    }
    public ClientFactory setReadTimeout(long readTimeout,TimeUnit unit) {
        this.readTimeout = unit.toMillis(readTimeout);
        return this;
    }
    public ClientFactory setHostAndPort(HostAndPort hostAndPort) {
        if(null == this.hostAndPort){
            synchronized(this){
                if(null == this.hostAndPort){
                    this.hostAndPort = checkNotNull(hostAndPort,"hostAndPort must not be null");
                }
            }
        }else{
            throw new IllegalStateException("the memeber hostAndPort be initialized always");
        }
        return this;
    }
    public ClientFactory setHostAndPort(String host,int port) {
        return setHostAndPort(fromParts(host, port));
    }
    public ClientFactory setHostAndPort(String host) {
        return setHostAndPort(fromString(host));
    }
    public ClientFactory setListener(AsyncClientBase.Listener listener) {
          if(null != listener){
                this.listener = listener;
          }
          return this;
    }    

    private GenericObjectPool<${thriftyClientClass}> getChannelPool() {
        if(null == channelPool){
            synchronized(this){
                if(null == channelPool){
                    channelPool = new GenericObjectPool<${thriftyClientClass}>(new ThriftClientPoolFactory(),channelPoolConfig);
                }
            }
        }
        return channelPool;
    }
    /**
     * return instance of {@link ${thriftyClientClass}}
     * @return
     */
    public ${thriftyClientClass} applyInstance() {
        try {
            return getChannelPool().borrowObject();
        } catch (Exception e) {
            Throwables.throwIfUnchecked(e);
            throw new RuntimeException(e);
        }
    }
    /**
     * release instance of {@code instance} that be applied by {@link ${esc.hash}applyInstance(Class)}
     * @param instance
     */
    public void releaseInstance(${interfaceClass} instance){
        if(instance instanceof ${thriftyClientClass}){
            getChannelPool().returnObject((${thriftyClientClass})instance);
        }
    }
    private class ThriftClientPoolFactory implements PooledObjectFactory<${thriftyClientClass}> {

        @Override
        public PooledObject<${thriftyClientClass}> makeObject() throws Exception {
            SocketTransport transport = 
                    new SocketTransport.Builder(hostAndPort.getHost(),hostAndPort.getPort())
                        .connectTimeout((int) connectTimeout)
                        .readTimeout((int) readTimeout).build();
            transport.connect();
            Protocol protocol = new BinaryProtocol(transport);
            return new DefaultPooledObject<${thriftyClientClass}>(new ${thriftPackage}.${serviceName}Client(protocol,listener));
        }

        @Override
        public void destroyObject(PooledObject<${thriftyClientClass}> p) throws Exception {
            logger.info("destroyObject");
            p.getObject().close();
        }

        @Override
        public boolean validateObject(PooledObject<${thriftyClientClass}> p) {
           
            return true;
        }

        @Override
        public void activateObject(PooledObject<${thriftyClientClass}> p) throws Exception {
        }

        @Override
        public void passivateObject(PooledObject<${thriftyClientClass}> p) throws Exception {
        }
    }
    public static ClientFactory builder() {
        return new ClientFactory();
    }
    @SuppressWarnings("unchecked")
    protected<I,O> O  build(Class<I> interfaceClass,final Class<O> destClass){
        try {
            return (O) CLIENT_CACHE.get(interfaceClass, new Callable<Object>(){
                @Override
                public Object call() throws Exception {
                    return destClass.getDeclaredConstructor(ClientFactory.class).newInstance(ClientFactory.this);
                }});
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
    /** get asynchronous instance of $serviceName */ 
    public #clientClass(true)  buildAsync(){
        return build(
                ${interfaceClass}.class,
                #clientClass(true).class);
    }
    /** get synchronized instance of $serviceName */ 
    public #clientClass(false) build(){
        return build(
                ${interfaceClass}.class,
                #clientClass(false).class);
    }
    public class ListenableFutureDecorator<A,V> implements ListenableFuture<V>{
        private final ${thriftyClientClass} async;
        private final ListenableFuture<V> future;
        private final AtomicBoolean released = new AtomicBoolean(false);
        public ListenableFutureDecorator(${thriftyClientClass} async, ListenableFuture<V> future) {
            this.async = checkNotNull(async,"async is null");
            this.future = checkNotNull(future,"future is null");
        }
        private void releaseAsync(){
            if(released.compareAndSet(false, true)){
                releaseInstance(async);    
            }
        }
        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
            return future.cancel(mayInterruptIfRunning);
        }

        @Override
        public V get() throws InterruptedException, ExecutionException {
            try{
                return future.get();
            }finally{
                releaseAsync();                
            }
        }

        @Override
        public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
            try{
                return future.get(timeout, unit);
            }finally{
                releaseAsync();
            }
        }

        @Override
        public boolean isCancelled() {
            return future.isCancelled();
        }

        @Override
        public boolean isDone() {
            return future.isDone();
        }

        @Override
        public void addListener(Runnable listener, Executor executor) {
            future.addListener(listener, executor);            
        }        
    }}
